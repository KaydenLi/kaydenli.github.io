<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>webpack</title>
    <url>/2020/02/26/webpack/</url>
    <content><![CDATA[<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><h2 id="1-Webpack的基本概念"><a href="#1-Webpack的基本概念" class="headerlink" title="1. Webpack的基本概念"></a>1. Webpack的基本概念</h2><p>   <code>webpack</code>它做的事情是，分析你的项目结构，找到<code>JavaScript</code>模块以及其它的一些浏览器不能直接运行的拓展语言（<code>Scss</code>，<code>TypeScript</code>等），并将其打包为合适的格式以供浏览器使用。</p>
<h2 id="2-webpack核心概念"><a href="#2-webpack核心概念" class="headerlink" title="2. webpack核心概念"></a>2. webpack核心概念</h2><p>1.Entry（入口）<br>   指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。<br>2. Output（出口）<br>   告诉 webpack 在哪里输出它所创建的结果文件，以及如何命名这些文件，默认值为./dist。<br>3. Loader（模块转换器）<br>   将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。<br>4. Plugins（插件）<br>   在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。<br>5. Module(模块)<br>   开发者将程序分解成离散功能块，并称之为模块，在webpack里一个模块对应着一个文件，webpack会从配置的 Entry 开始递归找出所有依赖的模块。</p>
<h2 id="3-webpack执行流程"><a href="#3-webpack执行流程" class="headerlink" title="3. webpack执行流程"></a>3. webpack执行流程</h2><p>   <code>webpack</code>启动后会在<code>entry</code>里配置的<code>module</code>开始递归解析<code>entry</code>所依赖的所有<code>module</code>，每找到一个<code>module</code>, 就会根据配置的<code>loader</code>去找相应的转换规则，对<code>module</code>进行转换后再解析当前<code>module</code>所依赖的<code>module</code>，这些模块会以<code>entry</code>为分组，一个<code>entry</code>和所有相依赖的<code>module</code>也就是一个<code>chunk</code>，最后<code>webpack</code>会把所有<code>chunk</code>转换成文件输出，在整个流程中<code>webpack</code>会在恰当的时机执行<code>plugin</code>的逻辑。</p>
<h2 id="4-loader"><a href="#4-loader" class="headerlink" title="4. loader"></a>4. loader</h2><p>   在webpack看来一切都是模块！这就是它不可不说的优点，包括你的JavaScript代码，也包括CSS和fonts以及图片等等等，只有通过合适的loaders，它们都可以被当做模块被处理。</p>
<p>文件</p>
<table>
<thead>
<tr>
<th align="center">laoder</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">raw-loader</td>
<td align="center">加载文件原始内容（utf-8）</td>
</tr>
<tr>
<td align="center">val-loader</td>
<td align="center">将代码作为模块执行，并将 exports 转为 JS 代码</td>
</tr>
<tr>
<td align="center">url-loader</td>
<td align="center">像 file loader 一样工作，但如果文件小于限制，可以返回 data URL</td>
</tr>
<tr>
<td align="center">file-loader</td>
<td align="center">将文件发送到输出文件夹，并返回（相对）URL</td>
</tr>
</tbody></table>
<p>JSON</p>
<table>
<thead>
<tr>
<th align="center">laoder</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">json-loader</td>
<td align="center">加载 JSON 文件（默认包含）</td>
</tr>
<tr>
<td align="center">json5-loader</td>
<td align="center">加载和转译 JSON 5 文件</td>
</tr>
<tr>
<td align="center">cson-loader</td>
<td align="center">加载和转译 CSON 文件</td>
</tr>
</tbody></table>
<p>转换编译(Transpiling)</p>
<table>
<thead>
<tr>
<th align="center">laoder</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">script-loader</td>
<td align="center">在全局上下文中执行一次 JavaScript 文件（如在 script 标签），不需要解析</td>
</tr>
<tr>
<td align="center">babel-loader</td>
<td align="center">加载 ES2015+ 代码，然后使用 Babel 转译为 ES5</td>
</tr>
<tr>
<td align="center">buble-loader</td>
<td align="center">使用 Bublé 加载 ES2015+ 代码，并且将代码转译为 ES5</td>
</tr>
<tr>
<td align="center">traceur-loader</td>
<td align="center">加载 ES2015+ 代码，然后使用 Traceur 转译为 ES5</td>
</tr>
<tr>
<td align="center">ts-loader或 awesome-typescript-loader</td>
<td align="center">像 JavaScript 一样加载 TypeScript 2.0+</td>
</tr>
<tr>
<td align="center">coffee-loader</td>
<td align="center">像 JavaScript 一样加载 CoffeeScript</td>
</tr>
</tbody></table>
<p>模板(Templating)</p>
<table>
<thead>
<tr>
<th align="center">laoder</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">html-loader</td>
<td align="center">导出 HTML 为字符串，需要引用静态资源</td>
</tr>
<tr>
<td align="center">pug-loader</td>
<td align="center">加载 Pug 模板并返回一个函数</td>
</tr>
<tr>
<td align="center">jade-loader</td>
<td align="center">加载 Jade 模板并返回一个函数</td>
</tr>
<tr>
<td align="center">markdown-loader</td>
<td align="center">将 Markdown 转译为 HTML</td>
</tr>
<tr>
<td align="center">react-markdown-loader</td>
<td align="center">使用 markdown-parse parser(解析器) 将 Markdown 编译为 React 组件</td>
</tr>
<tr>
<td align="center">posthtml-loader</td>
<td align="center">使用 PostHTML 加载并转换 HTML 文件</td>
</tr>
<tr>
<td align="center">handlebars-loader</td>
<td align="center">将 Handlebars 转移为 HTML</td>
</tr>
<tr>
<td align="center">markup-inline-loader</td>
<td align="center">将内联的 SVG/MathML 文件转换为 HTML。在应用于图标字体，或将 CSS 动画应用于 SVG 时非常有用。</td>
</tr>
</tbody></table>
<p>样式</p>
<table>
<thead>
<tr>
<th align="center">laoder</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">style-loader</td>
<td align="center">将模块的导出作为样式添加到 DOM 中</td>
</tr>
<tr>
<td align="center">css-loader</td>
<td align="center">解析 CSS 文件后，使用 import 加载，并且返回 CSS 代码</td>
</tr>
<tr>
<td align="center">less-loader</td>
<td align="center">加载和转译 LESS 文件</td>
</tr>
<tr>
<td align="center">sass-loader</td>
<td align="center">加载和转译 SASS/SCSS 文件</td>
</tr>
<tr>
<td align="center">postcss-loader</td>
<td align="center">使用 PostCSS 加载和转译 CSS/SSS 文件</td>
</tr>
<tr>
<td align="center">stylus-loader</td>
<td align="center">加载和转译 Stylus 文件</td>
</tr>
</tbody></table>
<p>清理和测试(Linting &amp;&amp; Testing)</p>
<table>
<thead>
<tr>
<th align="center">laoder</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mocha-loader</td>
<td align="center">使用 mocha 测试（浏览器/NodeJS）</td>
</tr>
<tr>
<td align="center">eslint-loader</td>
<td align="center">PreLoader，使用 ESLint 清理代码</td>
</tr>
<tr>
<td align="center">jshint-loader</td>
<td align="center">PreLoader，使用 JSHint 清理代码</td>
</tr>
<tr>
<td align="center">jscs-loader</td>
<td align="center">PreLoader，使用 JSCS 检查代码样式</td>
</tr>
<tr>
<td align="center">coverjs-loader</td>
<td align="center">PreLoader，使用 CoverJS 确定测试覆盖率</td>
</tr>
</tbody></table>
<p>框架(Frameworks)</p>
<table>
<thead>
<tr>
<th align="center">laoder</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vue-loader</td>
<td align="center">加载和转译 Vue 组件</td>
</tr>
<tr>
<td align="center">polymer-loader</td>
<td align="center">使用选择预处理器(preprocessor)处理，并且 require() 类似一等模块(first-class)的Web 组件</td>
</tr>
<tr>
<td align="center">angular2-template-loader</td>
<td align="center">加载和转译 Angular 组件</td>
</tr>
</tbody></table>
<h2 id="4-plugins"><a href="#4-plugins" class="headerlink" title="4. plugins"></a>4. plugins</h2><table>
<thead>
<tr>
<th align="center">Name</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AggressiveSplittingPlugin</td>
<td align="center">将原来的 chunk 分成更小的 chunk</td>
</tr>
<tr>
<td align="center">BabelMinifyWebpackPlugin</td>
<td align="center">使用 babel-minify进行压缩</td>
</tr>
<tr>
<td align="center">BannerPlugin</td>
<td align="center">在每个生成的 chunk 顶部添加 banner</td>
</tr>
<tr>
<td align="center">CommonsChunkPlugin</td>
<td align="center">提取 chunks 之间共享的通用模块</td>
</tr>
<tr>
<td align="center">CompressionWebpackPlugin</td>
<td align="center">预先准备的资源压缩版本，使用 Content-Encoding 提供访问服务</td>
</tr>
<tr>
<td align="center">ContextReplacementPlugin</td>
<td align="center">重写 require 表达式的推断上下文</td>
</tr>
<tr>
<td align="center">CopyWebpackPlugin</td>
<td align="center">将单个文件或整个目录复制到构建目录</td>
</tr>
<tr>
<td align="center">DefinePlugin</td>
<td align="center">允许在编译时(compile time)配置的全局常量</td>
</tr>
<tr>
<td align="center">DllPlugin</td>
<td align="center">为了极大减少构建时间，进行分离打包</td>
</tr>
<tr>
<td align="center">EnvironmentPlugin</td>
<td align="center">DefinePlugin 中 process.env 键的简写方式。</td>
</tr>
<tr>
<td align="center">ExtractTextWebpackPlugin</td>
<td align="center">从 bundle 中提取文本（CSS）到单独的文件</td>
</tr>
<tr>
<td align="center">HotModuleReplacementPlugin</td>
<td align="center">启用模块热替换(Enable Hot Module Replacement - HMR)</td>
</tr>
<tr>
<td align="center">HtmlWebpackPlugin</td>
<td align="center">简单创建 HTML 文件，用于服务器访问</td>
</tr>
<tr>
<td align="center">I18nWebpackPlugin</td>
<td align="center">为 bundle 增加国际化支持</td>
</tr>
<tr>
<td align="center">IgnorePlugin</td>
<td align="center">从 bundle 中排除某些模块</td>
</tr>
<tr>
<td align="center">LimitChunkCountPlugin</td>
<td align="center">设置 chunk 的最小/最大限制，以微调和控制 chunk</td>
</tr>
<tr>
<td align="center">LoaderOptionsPlugin</td>
<td align="center">用于从 webpack 1 迁移到 webpack 2</td>
</tr>
<tr>
<td align="center">MinChunkSizePlugin</td>
<td align="center">确保 chunk 大小超过指定限制</td>
</tr>
<tr>
<td align="center">NoEmitOnErrorsPlugin</td>
<td align="center">在输出阶段时，遇到编译错误跳过</td>
</tr>
<tr>
<td align="center">NormalModuleReplacementPlugin</td>
<td align="center">替换与正则表达式匹配的资源</td>
</tr>
<tr>
<td align="center">NpmInstallWebpackPlugin</td>
<td align="center">在开发时自动安装缺少的依赖</td>
</tr>
<tr>
<td align="center">ProvidePlugin</td>
<td align="center">不必通过 import/require 使用模块</td>
</tr>
<tr>
<td align="center">SourceMapDevToolPlugin</td>
<td align="center">对 source map 进行更细粒度的控制</td>
</tr>
<tr>
<td align="center">EvalSourceMapDevToolPlugin</td>
<td align="center">对 eval source map 进行更细粒度的控制</td>
</tr>
<tr>
<td align="center">UglifyjsWebpackPlugin</td>
<td align="center">可以控制项目中 UglifyJS 的版本</td>
</tr>
<tr>
<td align="center">ZopfliWebpackPlugin</td>
<td align="center">通过 node-zopfli 将资源预先压缩的版本</td>
</tr>
</tbody></table>]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>模块化</title>
    <url>/2020/02/26/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h1><h2 id="1-模块化概述"><a href="#1-模块化概述" class="headerlink" title="1. 模块化概述"></a>1. 模块化概述</h2><p>   模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的<code>js</code>模块化规范有<code>CommonJS</code>、<code>AMD</code>、<code>CMD</code>以及<code>ES6的模块系统</code>。<br>   作为一个模块化系统所必须的能力：定义封装的模块，定义新模块对其他模块的依赖，可对其他模块的引入支持等。</p>
<h2 id="2-CommonJS"><a href="#2-CommonJS" class="headerlink" title="2. CommonJS"></a>2. CommonJS</h2><p>   <code>Node.js</code>是<code>commonJS</code>规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。实际使用时，用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用<code>require</code>加载模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义模块math.js</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="comment">//在这里写上需要向外暴露的函数、变量</span></span><br><span class="line">  add: add,</span><br><span class="line">  basicNum: basicNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用自定义的模块时，参数包含路径，可省略.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用核心模块时，不需要带路径</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createService(...).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p><code>commonJS</code>用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>
<h2 id="3-AMD和require-js"><a href="#3-AMD和require-js" class="headerlink" title="3. AMD和require.js"></a>3. AMD和require.js</h2><p>   <code>AMD</code>规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用<code>require.js</code>实现<code>AMD</code>规范的模块化：用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。<br>   首先我们需要引入<code>require.js</code>文件和一个入口文件<code>main.js</code>。<code>main.js</code>中配置<code>require.config()</code>并规定项目中用到的基础模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 网页中引入require.js及main.js **/</span></span><br><span class="line">&lt;script src=<span class="string">"js/require.js"</span> data-main=<span class="string">"js/main"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  baseUrl: <span class="string">"js/lib"</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"jquery"</span>,<span class="string">"underscore"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$,_</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>   引用模块的时候，我们将模块名放在<code>[]</code>中作为<code>reqiure()</code>的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在<code>[]</code>中作为<code>define()</code>的第一参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义math.js模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: add,</span><br><span class="line">        basicNum :basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定义一个依赖underscore.js的模块</span></span><br><span class="line">define([<span class="string">'underscore'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">_</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> classify = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">    _.countBy(list,<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num &gt; <span class="number">30</span> ? <span class="string">'old'</span> : <span class="string">'young'</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    classify :classify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用模块，将模块放在[]内</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'jquery'</span>, <span class="string">'math'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$, math</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = math.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">  $(<span class="string">"#sum"</span>).html(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="4-CMD和sea-js"><a href="#4-CMD和sea-js" class="headerlink" title="4. CMD和sea.js"></a>4. CMD和sea.js</h2><p>require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span></span><br><span class="line">      b.foo()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>   <code>CMD</code>是另一种<code>js</code>模块化方案，它与<code>AMD</code>很类似，不同点在于：<code>AMD</code> 推崇依赖前置、提前执行，<code>CMD</code>推崇依赖就近、延迟执行。此规范其实是在<code>sea.js</code>推广过程中产生的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** AMD写法 **/</span></span><br><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) </span>&#123; </span><br><span class="line">     <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span></span><br><span class="line">        b.doSomething()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CMD写法 **/</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>); <span class="comment">//在需要时申明</span></span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">        b.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** sea.js **/</span></span><br><span class="line"><span class="comment">// 定义模块 math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery.js'</span>);</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    exports.add = add;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">'math.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = math.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="5-ES6-Module"><a href="#5-ES6-Module" class="headerlink" title="5. ES6 Module"></a>5. ES6 Module</h2><p>``ES6<code>在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：</code>export<code>和</code>import<code>。</code>export<code>命令用于规定模块的对外接口，</code>import`命令用于输入其他模块提供的功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 math.js **/</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; basicNum, add &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 引用模块 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">'./math'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    ele.textContent = add(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   如上例所示，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名。其实<code>ES6</code>还提供了<code>export default</code>命令，为模块指定默认输出，对应的<code>import</code>语句不需要使用大括号。这也更趋近于<code>ADM</code>的引用写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** export default **/</span></span><br><span class="line"><span class="comment">//定义输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; basicNum, add &#125;;</span><br><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">from</span> <span class="string">'./math'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    ele.textContent = math.add(<span class="number">99</span> + math.basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   <code>ES6</code>的模块不是对象，<code>import</code>命令会被 <code>JavaScript</code> 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>存储</title>
    <url>/2020/02/26/%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h2 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1. cookie"></a>1. cookie</h2><p>   <code>cookie</code>的大小限制为<code>4KB</code>左右。它的主要用途有保存登录信息，用来与服务器进行通信。</p>
<h2 id="2-localStorage"><a href="#2-localStorage" class="headerlink" title="2. localStorage"></a>2. localStorage</h2><p>   用于本地存储。除非被清除，否则数据将永久保存</p>
<h2 id="3-sessionStorage"><a href="#3-sessionStorage" class="headerlink" title="3. sessionStorage"></a>3. sessionStorage</h2><p>   用于本地存储。但是当页面关闭后数据就会清空。</p>
<h2 id="4-三者的比较"><a href="#4-三者的比较" class="headerlink" title="4. 三者的比较"></a>4. 三者的比较</h2><table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">Cookie</th>
<th align="center">localStorage</th>
<th align="center">sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据的生命期</td>
<td align="center">一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>
<td align="center">除非被清除，否则永久保存</td>
<td align="center">仅在当前会话下有效，关闭页面或浏览器后被清除</td>
</tr>
<tr>
<td align="center">存放数据大小</td>
<td align="center">4K左右</td>
<td align="center">一般为5MB</td>
<td align="center">同localStorage</td>
</tr>
<tr>
<td align="center">与服务器端通信</td>
<td align="center">每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>
<td align="center">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
<td align="center">同localStorage</td>
</tr>
<tr>
<td align="center">易用性</td>
<td align="center">需要程序员自己封装，源生的Cookie接口不友好</td>
<td align="center">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
<td align="center">同localStorage</td>
</tr>
</tbody></table>
<h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h2><p>   因为考虑到每个 <code>HTTP</code> 请求都会带着 <code>Cookie</code> 的信息，所以 <code>Cookie</code> 应该尽量精简。比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 <code>Cookie</code> 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。由于有存储功能，所以曾经还使用 <code>Cookie</code> 来保存用户在电商网站的购物车信息，如今有了 <code>localStorage</code>，似乎在这个方面也可以给 <code>Cookie</code> 放个假了~<br>   而另一方面 <code>localStorage</code> 接替了 <code>Cookie</code> 管理购物车的工作，同时也能胜任其他一些工作。比如<code>HTML5</code>游戏通常会产生一些本地数据，<code>localStorage</code> 也是非常适用的。如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 <code>sessionStorage</code> 的作用就发挥出来了。</p>
<h2 id="6-localStorage和sessionStorage操作"><a href="#6-localStorage和sessionStorage操作" class="headerlink" title="6. localStorage和sessionStorage操作"></a>6. localStorage和sessionStorage操作</h2><p><code>localStorage</code>和<code>sessionStorage</code>都具有相同的操作方法，例如<code>setItem</code>、<code>getItem</code>和<code>removeItem</code>等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//setItem存储value</span></span><br><span class="line">sessionStorage.setItem(<span class="string">"key"</span>, <span class="string">"value"</span>);</span><br><span class="line">localStorage.setItem(<span class="string">"site"</span>, <span class="string">"js8.in"</span>);</span><br><span class="line"><span class="comment">//getItem获取value</span></span><br><span class="line"><span class="keyword">var</span> value = sessionStorage.getItem(<span class="string">"key"</span>);   </span><br><span class="line"><span class="keyword">var</span> site = localStorage.getItem(<span class="string">"site"</span>);</span><br><span class="line"><span class="comment">//removeItem删除key</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">"key"</span>);   </span><br><span class="line">localStorage.removeItem(<span class="string">"site"</span>);</span><br><span class="line"><span class="comment">//clear清除所有的key/value</span></span><br><span class="line">sessionStorage.clear();</span><br><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2020/02/25/ajax/</url>
    <content><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h2 id="1-ajax"><a href="#1-ajax" class="headerlink" title="1. ajax"></a>1. ajax</h2><p>   <code>AJAX</code> =<code>Asynchronous JavaScript and XML</code>（异步的 <code>JavaScript</code> 和<code>XML</code>）。<code>AJAX</code> 不是新的编程语言，而是一种<strong>使用现有标准的新方法</strong>。<code>AJAX</code> 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。<code>AJAX</code> 不需要任何浏览器插件，但需要用户允许<code>JavaScript</code>在浏览器上执行。<br>   常见的<code>ajax</code>框架有<code>Fetch API</code>、<code>Axios</code>、<code>jQuery</code>、<code>SuperAgent</code>、<code>Request</code>等。其中，<code>Axios</code>是一个基于<code>XMLHttpRequest</code>而构建的现代<code>JavaScript</code>库，用于进行<code>AJAX</code>调用。它允许你从浏览器和服务器发出<code>HTTP</code>请求。此外，它还支持<code>ES6</code>原生的<code>Promise API</code>。<code>Axios</code>的其他突出特点包括：拦截请求和响应、使用<code>promise</code>转换请求和响应数据、自动转换<code>JSON</code>数据、取消实时请求。</p>
<h2 id="2-XMLHttpRequest"><a href="#2-XMLHttpRequest" class="headerlink" title="2. XMLHttpRequest"></a>2. XMLHttpRequest</h2><p>在实际开发中我们使用的各种网络请求框架是封装了的<code>XMLHttpRequest</code>对象。<br>一个简单封装<code>XMLHttpRequest</code>的例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.timeout = <span class="number">3000</span>;</span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">   alert(<span class="string">"请求超时！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> formData = &#123;&#125;；</span><br><span class="line"><span class="comment">//2.连接服务器 </span></span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'http://www.test.com:8000/login'</span>);</span><br><span class="line"><span class="comment">//3.发送请求</span></span><br><span class="line">xhr.send(formData);</span><br><span class="line"><span class="comment">//4.接收返回</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">      alert(xhr.responseText);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      alert(xhr.statusText);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>属性说明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">* xhr.readyState：XMLHttpRequest对象的状态，等于<span class="number">4</span>表示数据已经接收完毕。</span><br><span class="line">* xhr.status：服务器返回的状态码，等于<span class="number">200</span>表示一切正常。</span><br><span class="line">* xhr.responseText：服务器返回的文本数据</span><br><span class="line">* xhr.responseXML：服务器返回的XML格式的数据</span><br><span class="line">* xhr.statusText：服务器返回的状态文本。</span><br></pre></td></tr></table></figure>

<p><code>XMLHttpRequest</code>可以向不同域名的服务器发出<code>HTTP</code>请求，叫做CORS，可以进行CORS有两个条件:<br>1)浏览器要支持CORS<br>2)服务器允许跨域：响应头需要添加一下选项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">self.set_header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br><span class="line">self.set_header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'POST, GET, OPTIONS'</span>)</span><br><span class="line">self.set_header(<span class="string">'Access-Control-Max-Age'</span>, <span class="number">1000</span>)</span><br><span class="line">self.set_header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'*'</span>)</span><br><span class="line">self.set_header(<span class="string">'Content-type'</span>, <span class="string">'application/json'</span>)</span><br></pre></td></tr></table></figure>

<p>下面介绍跨域的相关知识。</p>
<h2 id="3-跨域"><a href="#3-跨域" class="headerlink" title="3. 跨域"></a>3. 跨域</h2><h3 id="0-同源策略"><a href="#0-同源策略" class="headerlink" title="0. 同源策略"></a>0. 同源策略</h3><p>   同源策略，它是由<code>Netscape</code>提出的一个著名的安全策略。所有支持<code>JavaScript</code> 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。同源策略是浏览器的行为。<br>   浏览器遵守同源策略，但是有若干个标签是允许跨域的，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"xxx"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>常见解决跨域问题的方式有<code>JSONP</code>、<code>CORS</code>等</p>
<h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1. JSONP"></a>1. JSONP</h3><p>   <code>jsonp</code> 的原理很简单，就是利用了<code>&lt;script&gt;</code>标签没有跨域限制的漏洞。当需要通讯时，通过<code>&lt;script&gt;</code>标签指向一个需要访问的地址并提供一个回调函数来接收数据。<code>JSONP</code> 使用简单且兼容性不错，但是只限于 <code>get</code> 请求。</p>
<h3 id="2-CORS"><a href="#2-CORS" class="headerlink" title="2. CORS"></a>2. CORS</h3><p>   CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<code>CORS</code> 需要浏览器和后端同时支持。<code>IE8、9</code>需要通过<code>XDomainRequest</code> 来实现。浏览器会自动进行<code>CORS</code>通信，实现<code>CORS</code>通信的关键是后端。只要后端实现了<code>CORS</code>，就实现了跨域。<br>   对于开发者来说，浏览器一旦发现 <code>ajax</code> 请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<br>   服务端设置<code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。虽然设置<code>CORS</code>和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。<br>   值得注意的是，通常使用CORS时，异步请求会被分为简单请求和非简单请求，非简单请求的区别是会先发一次预检请求。<br>   使用简单方便，更为安全；支持 POST 请求方式。但<code>CORS</code> 是一种新型的跨域问题的解决方案，存在兼容问题，仅支持 <code>IE 10</code> 以上。<br>详细介绍可查看<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a>。</p>
<h3 id="3-Server-Proxy"><a href="#3-Server-Proxy" class="headerlink" title="3. Server Proxy"></a>3. Server Proxy</h3><p>   服务器代理，顾名思义，当你需要有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发送回来。</p>]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>js事件</title>
    <url>/2020/02/25/js%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="js事件"><a href="#js事件" class="headerlink" title="js事件"></a>js事件</h1><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>   js的事件绑定在DOM元素中直接绑定，也可以在JavaScript代码中绑定，最常用的是绑定事件监听函数：<code>dom.addEventListener(&quot;click&quot;,func,false);</code>，对dom对象绑定事件，处理<code>click</code>事件，用func函数处理事件，false代表不使用捕获。<code>dom.removeEventListener(&quot;click&quot;, myFunction);</code>可移除绑定的事件。<br>   addEventListener()是标准的绑定事件监听函数的方法，但是，IE8.0及其以下版本不支持该方法，它使用attachEvent()来绑定事件监听函数。所以，这种绑定事件的方法必须要处理浏览器兼容问题。</p>
<p>鼠标事件</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">onclick</td>
<td align="center">点击对象触发</td>
</tr>
<tr>
<td align="center">oncontextmenu</td>
<td align="center">点击右键打开上下文菜单世触发</td>
</tr>
<tr>
<td align="center">ondblclick</td>
<td align="center">双击对象触发</td>
</tr>
<tr>
<td align="center">onmousedown</td>
<td align="center">鼠标按钮按下</td>
</tr>
<tr>
<td align="center">onmouseenter</td>
<td align="center">鼠标指针移动到元素上(事件不支持冒泡)</td>
</tr>
<tr>
<td align="center">onmouseleave</td>
<td align="center">鼠标指针移出元素(事件不支持冒泡)</td>
</tr>
<tr>
<td align="center">onmousemove</td>
<td align="center">元素上的指针移动时触发</td>
</tr>
<tr>
<td align="center">onmouseover</td>
<td align="center">鼠标移到元素上(事件支持冒泡)</td>
</tr>
<tr>
<td align="center">onmouseout</td>
<td align="center">鼠标从元素上移开(事件支持冒泡)</td>
</tr>
<tr>
<td align="center">onmouseup</td>
<td align="center">鼠标按键松开</td>
</tr>
</tbody></table>
<p>键盘事件</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">onkeydown</td>
<td align="center">某个键盘按键被按下</td>
</tr>
<tr>
<td align="center">onkeypress</td>
<td align="center">键盘按键被按下并松开</td>
</tr>
<tr>
<td align="center">onkeyup</td>
<td align="center">按键被松开</td>
</tr>
</tbody></table>
<h2 id="冒泡与捕获"><a href="#冒泡与捕获" class="headerlink" title="冒泡与捕获"></a>冒泡与捕获</h2><p>   一般的，事件分为三个阶段：捕获阶段、目标阶段和冒泡阶段。<br>（1）捕获阶段（Capture Phase）<br>   事件的第一个阶段是捕获阶段。事件从文档的根节点流向目标对象节点。途中经过各个层次的DOM 节点，并在各节点上触发捕获事件，直到到达事件的目标节点。捕获阶段的主要任务是建立传播路径，在冒泡阶段，事件会通过这个路径回溯到文档跟节点。<br>（2）目标阶段（Target Phase）<br>   当事件到达目标节点的，事件就进入了目标阶段。事件在目标节点上被触发，然后会逆向回流，直到传播至最外层的文档节点。<br>（3）冒泡阶段（Bubble Phase）<br>   事件在目标元素上触发后，并不在这个元素上终止。它会随着DOM树一层层向上冒泡，回溯到根节点。冒泡过程非常有用。它将我们从对特定元素的事件监听中释放出来，如果没有事件冒泡，我们需要监听很多不同的元素来确保捕获到想要的事件。<br>   有种可能是，某个DOM节点绑定了某事件监听器，本来是想当该DOM节点触发事件，才会执行回调函数。结果是该节点的某后代节点触发某事件，由于事件冒泡，该DOM节点事件也会触发，执行了回调函数，这样就违背了最初的本意了。因此有存在阻止冒泡的需求。一般得加上<code>event.stopPropagation()</code>方法就能阻止事件的冒泡。</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>   “事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown……）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。<br>   事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。其可以大量节省内存占用，减少事件注册，还可以实现当新增子对象时无需再次对其绑定（动态绑定事件）。<br>   使用事件委托，只需在 DOM 树中尽量最高的层次上添加一个事件处理程序即可。使用“事件委托”时，并不是说把事件委托给的元素越靠近顶层就越好。事件冒泡的过程也需要耗时，越靠近顶层，事件的”事件传播链”越长，也就越耗时。如果DOM嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失。</p>]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>DOM</title>
    <url>/2020/02/25/DOM/</url>
    <content><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>   文章大部分引用自：<a href="https://www.haorooms.com/post/js_dom_api" target="_blank" rel="noopener">总结js常用的dom操作（js的dom操作API）</a></p>
<h2 id="1-DOM的本质"><a href="#1-DOM的本质" class="headerlink" title="1. DOM的本质"></a>1. DOM的本质</h2><p>   <code>DOM</code>（文档对象模型）是针对 <code>HTML</code> 和 <code>XML</code> 文档的一个<code>API</code>（应用程序编程接口）。<code>DOM</code> 描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。<code>DOM</code> 脱胎于 <code>Netscape</code> 及微软公司创始的 <code>DHTML</code>（<code>动态 HTML</code>），但现在它已经成为表现和操作页面标记的真正的跨平台、语言中立的方式。1998 年 10 月 <code>DOM 1</code> 级规范成为 <code>W3C</code> 的推荐标准，为基本的文档结构及查询提供了接口。</p>
<h2 id="2-获取结点API"><a href="#2-获取结点API" class="headerlink" title="2. 获取结点API"></a>2. 获取结点API</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">document.getElementById()</td>
<td align="center">根据ID查找元素，大小写敏感，如果有多个结果，只返回第一个</td>
</tr>
<tr>
<td align="center">document.getElementsByClassName()</td>
<td align="center">根据类名查找元素，多个类名用空格分隔，返回一个 HTMLCollection 。IE9+（含）。其它元素也支持 getElementsByClassName 方法</td>
</tr>
<tr>
<td align="center">document.getElementsByTagName()</td>
<td align="center">根据标签查找元素， * 表示查询所有标签，返回一个 HTMLCollection</td>
</tr>
<tr>
<td align="center">document.getElementsByName()</td>
<td align="center">根据元素的name属性查找，返回一个 NodeList</td>
</tr>
<tr>
<td align="center">document.querySelector()</td>
<td align="center">返回单个Node，IE8+(含），如果匹配到多个结果，只返回第一个</td>
</tr>
<tr>
<td align="center">document.querySelectorAll()</td>
<td align="center">返回一个 NodeList ，IE8+(含）</td>
</tr>
<tr>
<td align="center">document.forms()</td>
<td align="center">获取当前页面所有form，返回一个 HTMLCollection</td>
</tr>
</tbody></table>
<h2 id="3-节点创建API"><a href="#3-节点创建API" class="headerlink" title="3. 节点创建API"></a>3. 节点创建API</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">createElement()</td>
<td align="center">创建元素。通过 <code>createElement</code> 创建的元素并不属于 <code>document</code>对象，它只是创建出来，并未添加到<code>html</code>文档中，要调用 <code>appendChild</code> 或 <code>insertBefore</code> 等方法将其添加到<code>HTML</code>文档中</td>
</tr>
<tr>
<td align="center">createTextNode()</td>
<td align="center">创建文本节点</td>
</tr>
<tr>
<td align="center">cloneNode()</td>
<td align="center">克隆一个节点。它接收一个<code>bool</code>参数，用来表示是否复制子元素。克隆节点并不会克隆用 <code>addEventListener</code> 和 <code>node.onclick=xxx</code> 方式绑定的事件</td>
</tr>
<tr>
<td align="center">createDocumentFragment()</td>
<td align="center">用来创建一个 DocumentFragment ，也就是文档碎片，它表示一种轻量级的文档，主要是用来存储临时节点，大量操作DOM时用它可以大大提升性能</td>
</tr>
</tbody></table>
<h2 id="4-节点修改API"><a href="#4-节点修改API" class="headerlink" title="4. 节点修改API"></a>4. 节点修改API</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">appendChild()</td>
<td align="center">parent.appendChild(child);</td>
</tr>
<tr>
<td align="center">insertBefore()</td>
<td align="center">parentNode.insertBefore(newNode, refNode);</td>
</tr>
<tr>
<td align="center">replaceChild</td>
<td align="center">parent.replaceChild(newChild, oldChild);</td>
</tr>
<tr>
<td align="center">removeChild</td>
<td align="center">var deletedChild = parent.removeChild(node);</td>
</tr>
</tbody></table>
<h2 id="5-节点关系API"><a href="#5-节点关系API" class="headerlink" title="5. 节点关系API"></a>5. 节点关系API</h2><ol>
<li>父关系API</li>
</ol>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">parentNode</td>
<td align="center">每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment</td>
</tr>
<tr>
<td align="center">parentElement</td>
<td align="center">返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element元素，如果不是，则返回null</td>
</tr>
</tbody></table>
<p>2、子关系API</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">children</td>
<td align="center">返回一个实时的 HTMLCollection ，子节点都是Element，IE9以下浏览器不支持</td>
</tr>
<tr>
<td align="center">childNodes</td>
<td align="center">返回一个实时的 NodeList ，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等</td>
</tr>
<tr>
<td align="center">firstChild</td>
<td align="center">返回第一个子节点，不存在返回null，与之相对应的还有一个 firstElementChild</td>
</tr>
<tr>
<td align="center">lastChild</td>
<td align="center">返回最后一个子节点，不存在返回null，与之相对应的还有一个 lastElementChild</td>
</tr>
</tbody></table>
<p>3、兄弟关系型API</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">previousSibling</td>
<td align="center">节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下</td>
</tr>
<tr>
<td align="center">nextSibling</td>
<td align="center">节点的后一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下</td>
</tr>
<tr>
<td align="center">previousElementSibling</td>
<td align="center">返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持</td>
</tr>
<tr>
<td align="center">nextElementSibling</td>
<td align="center">返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持</td>
</tr>
</tbody></table>
<h2 id="6-元素属性型API"><a href="#6-元素属性型API" class="headerlink" title="6. 元素属性型API"></a>6. 元素属性型API</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">setAttribute()</td>
<td align="center">element.setAttribute(name, value);</td>
</tr>
<tr>
<td align="center">getAttribute()</td>
<td align="center">var value = element.getAttribute(“id”);</td>
</tr>
<tr>
<td align="center">hasAttribute()</td>
<td align="center">var result = element.hasAttribute(name);</td>
</tr>
<tr>
<td align="center">dataset()</td>
<td align="center">获取html data-开头的属性</td>
</tr>
</tbody></table>
<h2 id="7-样式相关API"><a href="#7-样式相关API" class="headerlink" title="7. 样式相关API"></a>7. 样式相关API</h2><p>1、直接修改元素的样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">elem.style.color = <span class="string">'red'</span>;  </span><br><span class="line">elem.style.setProperty(<span class="string">'font-size'</span>, <span class="string">'16px'</span>);  </span><br><span class="line">elem.style.removeProperty(<span class="string">'color'</span>);</span><br></pre></td></tr></table></figure>
<p>2、动态添加样式规则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);  </span><br><span class="line">style.innerHTML = <span class="string">'body&#123;color:red&#125; #top:hover&#123;background-color: red;color: white;&#125;'</span>;  </span><br><span class="line"><span class="built_in">document</span>.head.appendChild(style);</span><br></pre></td></tr></table></figure>
<p>3、classList获取样式class</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// div is an object reference to a &lt;div&gt; element with class="foo bar"</span></span><br><span class="line">div.classList.remove(<span class="string">"foo"</span>);</span><br><span class="line">div.classList.add(<span class="string">"anotherclass"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// if visible is set remove it, otherwise add it</span></span><br><span class="line">div.classList.toggle(<span class="string">"visible"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add/remove visible, depending on test conditional, i less than 10</span></span><br><span class="line">div.classList.toggle(<span class="string">"visible"</span>, i &lt; <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line">alert(div.classList.contains(<span class="string">"foo"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// add or remove multiple classes</span></span><br><span class="line">div.classList.add(<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>);</span><br><span class="line">div.classList.remove(<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add or remove multiple classes using spread syntax</span></span><br><span class="line"><span class="keyword">let</span> cls = [<span class="string">"foo"</span>, <span class="string">"bar"</span>];</span><br><span class="line">div.classList.add(...cls); </span><br><span class="line">div.classList.remove(...cls);</span><br><span class="line"></span><br><span class="line"><span class="comment">// replace class "foo" with class "bar"</span></span><br><span class="line">div.classList.replace(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br></pre></td></tr></table></figure>
<p>4、window.getComputedStyle<br>   通过 <code>element.sytle.xxx</code> 只能获取到内联样式，借助 <code>window.getComputedStyle</code> 可以获取应用到元素上的所有样式，<code>IE8</code>或更低版本不支持此方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> style = <span class="built_in">window</span>.getComputedStyle(element[, pseudoElt]);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>BOM</title>
    <url>/2020/02/25/BOM/</url>
    <content><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="1-BOM的基本概念"><a href="#1-BOM的基本概念" class="headerlink" title="1. BOM的基本概念"></a>1. BOM的基本概念</h2><p>   BOM(Browser Object Mode) 就是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的 Window 对象是BOM的顶层对象，其他对象都是该对象的子对象。javacsript 是通过访问 BOM对象来访问、控制、修改客户端(浏览器)的，即 BOM 提供了与浏览器交互的方法和接口；与此类似的是 DOM，它提供了处理网页内容的方法和接口。</p>
<h2 id="2-Window对象"><a href="#2-Window对象" class="headerlink" title="2. Window对象"></a>2. Window对象</h2><p>Window 对象通常可实现如下功能：弹出新的浏览器窗口；移动、关闭浏览器窗口及调整窗口大小；在浏览器窗口中实现页面的前进、后退功能。</p>
<table>
<thead>
<tr>
<th align="center">属性方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">history</td>
<td align="center">有关客户访问过的URL的信息。</td>
</tr>
<tr>
<td align="center">location</td>
<td align="center">有关当前URL的信息。</td>
</tr>
<tr>
<td align="center">screen</td>
<td align="center">只读属性，包含有关客户端显示屏的信息。</td>
</tr>
<tr>
<td align="center">prompt()</td>
<td align="center">显示可提示用户输入的对话框。</td>
</tr>
<tr>
<td align="center">alert()</td>
<td align="center">显示一个带有提示信息和一个“确定”按钮的警示对话框。</td>
</tr>
<tr>
<td align="center">confirm()</td>
<td align="center">显示一个带有提示信息、“确定”和“取消”按钮的对话框。</td>
</tr>
<tr>
<td align="center">close()</td>
<td align="center">关闭浏览器窗口。</td>
</tr>
<tr>
<td align="center">open()</td>
<td align="center">打开一个新的浏览器窗口，加载给定URL所指定的文档。</td>
</tr>
<tr>
<td align="center">setTimeout()</td>
<td align="center">在指定的毫秒数后调用函数或计算表达式。</td>
</tr>
<tr>
<td align="center">setInterval()</td>
<td align="center">按照指定的周期（以毫秒计）来调用函数或表达式。</td>
</tr>
</tbody></table>
<h2 id="3-window对象的子对象"><a href="#3-window对象的子对象" class="headerlink" title="3. window对象的子对象"></a>3. window对象的子对象</h2><h3 id="1-location对象"><a href="#1-location对象" class="headerlink" title="1. location对象"></a>1. location对象</h3><p><code>location</code> 是一个静态对象，该对象是对当前窗口 URL 地址的解析。该对象提供了可以访问 URL 中不同部分的信息属性，通过 <code>location</code> 对象也可以实现页面或锚点跳转等功能。</p>
<table>
<thead>
<tr>
<th align="center">属性方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">href</td>
<td align="center">返回或设置当前文档的URL</td>
</tr>
<tr>
<td align="center">search</td>
<td align="center">返回URL中的查询字符串部分。</td>
</tr>
<tr>
<td align="center">hash</td>
<td align="center">返回URL#后面的内容，如果没有#，返回空。</td>
</tr>
<tr>
<td align="center">host</td>
<td align="center">返回URL中的域名部分</td>
</tr>
<tr>
<td align="center">hostname</td>
<td align="center">返回URL中的主域名部分，例如dreamdu.com。</td>
</tr>
<tr>
<td align="center">pathname</td>
<td align="center">返回URL的域名后的部分。</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">返回URL中的端口部分。</td>
</tr>
<tr>
<td align="center">protocol</td>
<td align="center">返回URL中的协议部分。</td>
</tr>
<tr>
<td align="center">assign</td>
<td align="center">设置当前文档的URL。</td>
</tr>
<tr>
<td align="center">replace()</td>
<td align="center">设置当前文档的URL，并且在history对象的地址列表中移除这个URL location.replace(url);</td>
</tr>
<tr>
<td align="center">reload()</td>
<td align="center">重载当前页面。</td>
</tr>
</tbody></table>
<h3 id="2-history对象"><a href="#2-history对象" class="headerlink" title="2. history对象"></a>2. history对象</h3><p>   <code>history</code>对象来保存浏览器历史记录信息，也就是用户访问的页面。浏览器的前进与后退功能本质上就是 <code>history</code> 的操作。<code>history</code> 对象记录了用户浏览过的页面，通过该对象提供的 API 可以实现与浏览器前进/后退类似的导航功能。</p>
<table>
<thead>
<tr>
<th align="center">属性方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">go()</td>
<td align="center">前进或后退指定的页面数 history.go(num)。</td>
</tr>
<tr>
<td align="center">back()</td>
<td align="center">后退一页。</td>
</tr>
<tr>
<td align="center">forward()</td>
<td align="center">前进一页。</td>
</tr>
</tbody></table>
<h3 id="3-Navigator对象"><a href="#3-Navigator对象" class="headerlink" title="3. Navigator对象"></a>3. Navigator对象</h3><p><code>navigator</code> 是指浏览器对象，该对象提供了当前正在使用的浏览器的信息。<code>navigator</code> 对象中的属性是只读的，在 W3C 在 HTML5 标准中，对该对象进行了规范。由于浏览器的同，该对象的具体值可能有所区别。</p>
<table>
<thead>
<tr>
<th align="center">属性方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">userAgent</td>
<td align="center">返回用户代理头的字符串表示。</td>
</tr>
<tr>
<td align="center">cookieEnabled</td>
<td align="center">返回浏览器是否支持(启用)cookie。</td>
</tr>
</tbody></table>
<h3 id="4-screen对象"><a href="#4-screen对象" class="headerlink" title="4. screen对象"></a>4. screen对象</h3><p><code>screen</code> 对象中包含了用户显示器屏幕相关信息。通过该对象，可以访问用户显示器屏幕宽、高、色深等信息。</p>
<h3 id="5-DOM（document）相关对象"><a href="#5-DOM（document）相关对象" class="headerlink" title="5. DOM（document）相关对象"></a>5. DOM（document）相关对象</h3><p>DOM 可以认为是 BOM 的一个子集，DOM 中文档操作相关对象，如：<code>Node</code>、<code>Document</code>、<code>Element</code>等 DOM 节点类型对象，都是做为 <code>window</code> 对象的子属性出现的。<code>document</code> 是 <code>window</code> 对象的一个属性，它是一个 <code>document</code> 对象实例，表示当前窗口中文档对象。通过该对象，可以对文档和文档中元素、节点等进行操作。</p>
<h3 id="6-frames-对象"><a href="#6-frames-对象" class="headerlink" title="6. frames 对象"></a>6. frames 对象</h3><p><code>frames</code> 对象是一个集合，表示当前页面中使用的子框架。如果页面中使用了框架，将产生一个框架集合 <code>frames</code>，在集合中可以用数字下标（从 0 开始）或名字索引框架。集全中的每一个对象，包含了框架的页面布局信息，以及每一个框架所对应的 <code>window</code> 对象。</p>]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>js之日期、Math、对象、数组</title>
    <url>/2020/02/25/js%E4%B9%8B%E6%97%A5%E6%9C%9F%E3%80%81math%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="js之日期、Math、对象、数组"><a href="#js之日期、Math、对象、数组" class="headerlink" title="js之日期、Math、对象、数组"></a>js之日期、Math、对象、数组</h1><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><h3 id="1-创建-Date-对象的语法"><a href="#1-创建-Date-对象的语法" class="headerlink" title="1. 创建 Date 对象的语法"></a>1. 创建 Date 对象的语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDate = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br></pre></td></tr></table></figure>

<h3 id="2-Date属性"><a href="#2-Date属性" class="headerlink" title="2. Date属性"></a>2. Date属性</h3><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">constructor</td>
<td align="center">返回对创建此对象的 Date 函数的引用。</td>
</tr>
<tr>
<td align="center">prototype</td>
<td align="center">使您有能力向对象添加属性和方法。</td>
</tr>
</tbody></table>
<h3 id="3-Date方法"><a href="#3-Date方法" class="headerlink" title="3. Date方法"></a>3. Date方法</h3><table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Date()</td>
<td align="center">返回当日的日期和时间。</td>
</tr>
<tr>
<td align="center">getDate()</td>
<td align="center">从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="center">getDay()</td>
<td align="center">从 Date 对象返回一周中的某一天 (0 ~ 6)。</td>
</tr>
<tr>
<td align="center">getMonth()</td>
<td align="center">从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="center">getFullYear()</td>
<td align="center">从 Date 对象以四位数字返回年份。</td>
</tr>
<tr>
<td align="center">getYear()</td>
<td align="center">请使用 getFullYear() 方法代替。</td>
</tr>
<tr>
<td align="center">getHours()</td>
<td align="center">返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="center">getMinutes()</td>
<td align="center">返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="center">getSeconds()</td>
<td align="center">返回 Date 对象的秒数 (0 ~ 59)。</td>
</tr>
<tr>
<td align="center">getMilliseconds()</td>
<td align="center">返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td align="center">getTime()</td>
<td align="center">返回 1970 年 1 月 1 日至今的毫秒数。</td>
</tr>
</tbody></table>
<h2 id="MATH"><a href="#MATH" class="headerlink" title="MATH"></a>MATH</h2><h3 id="Math方法"><a href="#Math方法" class="headerlink" title="Math方法"></a>Math方法</h3><p><code>Math.random()</code> 返回介于 <code>0</code>（包括） 与<code>1</code>（不包括） 之间的随机数；<br><code>Math.round(x)</code> 的返回值是 <code>x</code> 四舍五入为最接近的整数。<br><code>Math.abs(x)</code> 返回 <code>x</code> 的绝对（正）值。<br><code>Math.ceil(x)</code> 的返回值是 <code>x</code> 上舍入最接近的整数。<br><code>Math.floor(x)</code> 的返回值是 <code>x</code> 下舍入最接近的整数。<br><code>Math.min()</code> 和 <code>Math.max()</code> 可用于查找参数列表中的最低或最高值。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><p>for(key in obj){ } 方法</p>
<h2 id="数组API"><a href="#数组API" class="headerlink" title="数组API"></a>数组API</h2><table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">作用</th>
<th align="center">改变arr</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">arr.join(“,”)</td>
<td align="center">用连接符把数组里面的元素连接成字符串</td>
<td align="center">不会</td>
<td>连接后的数组</td>
</tr>
<tr>
<td align="center">arr.concat(“a”,”b”,arr1)</td>
<td align="center">数组拼接</td>
<td align="center">不会</td>
<td>拼接后的数组</td>
</tr>
<tr>
<td align="center">arr.slice(start[,end])</td>
<td align="center">数组截取。含头不含尾。 支持负数，表示倒数第几个</td>
<td align="center">不会</td>
<td>截取后的数组</td>
</tr>
<tr>
<td align="center">arr.splice(start,n[,value1,value2…])</td>
<td align="center">删除、插入、替换</td>
<td align="center">会</td>
<td>所有被删除元素组成的子数组</td>
</tr>
<tr>
<td align="center">arr.reverse()</td>
<td align="center">翻转数组</td>
<td align="center">会</td>
<td>翻转后的数组</td>
</tr>
<tr>
<td align="center">arr.sort()</td>
<td align="center">排序</td>
<td align="center">会</td>
<td>排序后的数组</td>
</tr>
<tr>
<td align="center">arr.indexOf(value[,from])或arr.lastIndexOf(value[,from])</td>
<td align="center">查找元素在数组中的位置</td>
<td align="center">不会</td>
<td>查找元素所在位置，找不到时返回<code>-1</code></td>
</tr>
<tr>
<td align="center">arr.some(function(value,index,arr){ return value &gt; 7; })</td>
<td align="center">判断数组中有没有符合条件的元素，只要遇到符合条件的就退出循环</td>
<td align="center">不会</td>
<td><code>Boolean</code>值</td>
</tr>
<tr>
<td align="center">arr.every(function(value,index,arr){return value &gt; 7;})</td>
<td align="center">判断数组中的元素是否都符合条件</td>
<td align="center">不会</td>
<td><code>Boolean</code>值</td>
</tr>
<tr>
<td align="center">arr.filter(function(value,index,arr){return value &gt; 7;})</td>
<td align="center">过滤数组</td>
<td align="center">不会</td>
<td>符合条件的元素组成的新数组</td>
</tr>
<tr>
<td align="center">arr.forEach(function(value,index,arr){})</td>
<td align="center">遍历数组</td>
<td align="center">可能会</td>
<td><code>undefined</code></td>
</tr>
<tr>
<td align="center">arr.map(function(value,index,arr){})</td>
<td align="center">遍历数组</td>
<td align="center">可能会</td>
<td>调用函数处理后的数组</td>
</tr>
<tr>
<td align="center">arr.reduce(function(prev,value,index,arr){return prev + value; })</td>
<td align="center"><code>prev</code>是之前那些元素的和</td>
<td align="center">不会</td>
<td>数组里面所有元素相加的和</td>
</tr>
<tr>
<td align="center">String(arr)或arr.toString()</td>
<td align="center">将数组中的元素用逗号连接成字符串，类似于<code>arr.join(&quot;,&quot;)</code></td>
<td align="center">不会</td>
<td>字符串</td>
</tr>
<tr>
<td align="center">arr.unshift(value)</td>
<td align="center">数组的最开头插入元素</td>
<td align="center">会</td>
<td>新数组的长度</td>
</tr>
<tr>
<td align="center">arr.shift()</td>
<td align="center">从数组最开头删除元素</td>
<td align="center">会</td>
<td>被弹出的元素</td>
</tr>
<tr>
<td align="center">arr.push(value1[,value2,arr1])</td>
<td align="center">在数组末尾追加元素，追加进去的数组不会被打散</td>
<td align="center">会</td>
<td>新数组的长度</td>
</tr>
<tr>
<td align="center">arr.pop()</td>
<td align="center">从数组最末尾删除元素</td>
<td align="center">会</td>
<td>被弹出的元素</td>
</tr>
</tbody></table>]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>js基础知识点总结</title>
    <url>/2020/02/25/js%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="js-基础知识点总结"><a href="#js-基础知识点总结" class="headerlink" title="js 基础知识点总结"></a>js 基础知识点总结</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><p>   数据类型分为值类型和引用类型。<br>   值类型包括（也称为基本类型）：字符串（<code>String</code>）、数字(<code>Number</code>)、布尔(<code>Boolean</code>)、空（<code>Null</code>）、未定义（<code>Undefined</code>）、<code>Symbol</code>。<code>Symbol</code> 是 <code>ES6</code> 引入了一种新的原始数据类型，表示独一无二的值。<br>   引用数据类型包括：对象(Object)、数组(Array)、函数(Function)。<br>   基本类型的变量值是存放在栈内存（Stack）中；引用类型在栈内存中保存了变量标识符和指向堆内存中该对象的指针，具体值是保存在堆内存（Heap）中的。</p>
<h2 id="2-typeof-操作符"><a href="#2-typeof-操作符" class="headerlink" title="2. typeof 操作符"></a>2. typeof 操作符</h2><p>   <code>typeof</code>可以识别基本类型变量的类型，<code>null</code>会识别为<code>object</code>，引用类型无法识别，但可以识别函数，如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">"kayden"</span>			<span class="comment">//string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>		<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>				<span class="comment">//number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>				<span class="comment">//boolean</span></span><br><span class="line"><span class="keyword">typeof</span> []				<span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;				<span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> 			<span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log		<span class="comment">//function</span></span><br></pre></td></tr></table></figure>

<h2 id="3-强制类型转换"><a href="#3-强制类型转换" class="headerlink" title="3. 强制类型转换"></a>3. 强制类型转换</h2><p>   常见的会发生类型转换的场景：字符串拼接、== 运算符、if 语句、逻辑运算。判断一个变量会被当做<code>true</code>还是<code>false</code>时，使用<code>!!</code>，如<code>var a=100；console.log(!!a);//true</code>。会转换为<code>false</code>的值包括<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code>。<br>   三等和双等何时使用？当判断一个对象（函数、Array等也是对象）的属性是否存时，可以使用双等，其他情况下应该使用三等。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj.a == <span class="literal">null</span>)&#123;</span><br><span class="line">   <span class="comment">//这里的双等相当于 obj.a === null || obj.a === undefined 简写形式</span></span><br><span class="line">   <span class="comment">//这是 jQuery 源码推荐的写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-内置函数和内置对象"><a href="#4-内置函数和内置对象" class="headerlink" title="4. 内置函数和内置对象"></a>4. 内置函数和内置对象</h2><p>   内置函数包括：Object、Array、Date、String、Error、Function、RegExp、Boolean、Number。内置对象包括：JSON、Math。</p>
<h2 id="5-JSON"><a href="#5-JSON" class="headerlink" title="5. JSON"></a>5. JSON</h2><p>   JSON既是js的内置对象，也是一种数据格式。作为对象时其常用的API有</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>:<span class="number">10</span>,<span class="attr">b</span>:<span class="string">'20'</span>&#125;)<span class="comment">//解析JSON字符串并返回对应的对象</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a":10,"b":20&#125;'</span>)<span class="comment">//解析对象并返回与指定值对应的JSON字符串</span></span><br></pre></td></tr></table></figure>

<h2 id="6-构造函数"><a href="#6-构造函数" class="headerlink" title="6. 构造函数"></a>6. 构造函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">   <span class="keyword">this</span>.age = age;</span><br><span class="line">   <span class="comment">//return this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'zhangsan'</span>,<span class="number">30</span>);</span><br><span class="line"><span class="comment">//var f1 = new Foo('lisi',20);创建多个对象</span></span><br></pre></td></tr></table></figure>
<p>   显著特特点：函数名大写。<br>   <code>var a = {}</code>其实是<code>var a = new Object()</code>的语法糖。<br>   <code>var a = []</code>其实是<code>var a = new Array()</code>的语法糖。<br>   <code>function Foo(){...}</code>其实是<code>var Foo = new Function()</code>的语法糖。</p>
<h2 id="7-instanceof操作符"><a href="#7-instanceof操作符" class="headerlink" title="7. instanceof操作符"></a>7. instanceof操作符</h2><p>   使用<code>instanceof</code>来判断一个函数是否是一个变量的构造函数（变量是否是构造函数的实例）。例如判断一个变量是否为数组变量：<code>var a = [];a instanceof Array;//true</code>。<br>   <code>f instanceof Foo</code>的判断逻辑是<code>f</code>的<code>__proto__</code>一层一层往上找，能否得到<code>Foo.prototype</code>；再试着判断 <code>f instancdof Object</code>。</p>
<h2 id="8-原型规则"><a href="#8-原型规则" class="headerlink" title="8. 原型规则"></a>8. 原型规则</h2><h3 id="1-所有的引用类型（数组、对象、函数）都具有对象特性，即可自由拓展属性，但是null除外。"><a href="#1-所有的引用类型（数组、对象、函数）都具有对象特性，即可自由拓展属性，但是null除外。" class="headerlink" title="1. 所有的引用类型（数组、对象、函数）都具有对象特性，即可自由拓展属性，但是null除外。"></a>1. 所有的引用类型（数组、对象、函数）都具有对象特性，即可自由拓展属性，但是<code>null</code>除外。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;; obj.a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> arr = &#123;&#125;; arr.a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">fn.a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-所有的引用类型（数组、对象、函数）实例，都有一个-proto-属性（隐式原型），属性值是一个普通对象。"><a href="#2-所有的引用类型（数组、对象、函数）实例，都有一个-proto-属性（隐式原型），属性值是一个普通对象。" class="headerlink" title="2. 所有的引用类型（数组、对象、函数）实例，都有一个__proto__属性（隐式原型），属性值是一个普通对象。"></a>2. 所有的引用类型（数组、对象、函数）实例，都有一个<code>__proto__</code>属性（隐式原型），属性值是一个普通对象。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;; obj.a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> arr = &#123;&#125;; arr.a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">fn.a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(fn.__proto__)</span><br></pre></td></tr></table></figure>
<h3 id="3-所有的函数都有一个prototype属性（显式原型），属性值也是一个普通对象。"><a href="#3-所有的函数都有一个prototype属性（显式原型），属性值也是一个普通对象。" class="headerlink" title="3. 所有的函数都有一个prototype属性（显式原型），属性值也是一个普通对象。"></a>3. 所有的函数都有一个<code>prototype</code>属性（显式原型），属性值也是一个普通对象。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">fn.a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(fn.prototype)</span><br></pre></td></tr></table></figure>
<h3 id="4-所有的引用类型（数组、对象、函数）实例，它的-proto-属性值指向它的构造函数的prototype属性值。"><a href="#4-所有的引用类型（数组、对象、函数）实例，它的-proto-属性值指向它的构造函数的prototype属性值。" class="headerlink" title="4. 所有的引用类型（数组、对象、函数）实例，它的__proto__属性值指向它的构造函数的prototype属性值。"></a>4. 所有的引用类型（数组、对象、函数）实例，它的<code>__proto__</code>属性值指向它的构造函数的<code>prototype</code>属性值。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype)		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="5-当试图得到一个对象的某个属性值时，如果这个对象本身没有这个属性，那么会去它的-proto-（即它的构造函数的prototype）中寻找。"><a href="#5-当试图得到一个对象的某个属性值时，如果这个对象本身没有这个属性，那么会去它的-proto-（即它的构造函数的prototype）中寻找。" class="headerlink" title="5. 当试图得到一个对象的某个属性值时，如果这个对象本身没有这个属性，那么会去它的__proto__（即它的构造函数的prototype）中寻找。"></a>5. 当试图得到一个对象的某个属性值时，如果这个对象本身没有这个属性，那么会去它的<code>__proto__</code>（即它的构造函数的<code>prototype</code>）中寻找。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.alertName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建实例</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'ZhangSan'</span>);</span><br><span class="line">f.pprintName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">f.printName();</span><br><span class="line">f.alertName()</span><br></pre></td></tr></table></figure>

<h2 id="9-hasOwnProperty函数"><a href="#9-hasOwnProperty函数" class="headerlink" title="9. hasOwnProperty函数"></a>9. hasOwnProperty函数</h2><p>   检测集合成员的所属关系，判断某个属性是否存在于某个对象中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a.hasOwnProperty(<span class="string">'age'</span>))=&gt;<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="10-原型链"><a href="#10-原型链" class="headerlink" title="10. 原型链"></a>10. 原型链</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'ZhangSan'</span>);</span><br><span class="line">f.toString();<span class="comment">//要去 f.__proto__.__proto__去找</span></span><br></pre></td></tr></table></figure>
<p><img src="http://q65s4i59e.bkt.clouddn.com/prototype.jpg" alt="原型链"><br>   需要注意的是，<code>Object.__proto__</code>指向<code>null</code>。<br>一个原型链的实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetId</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.ele = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">&#125;</span><br><span class="line">GetId.prototype.html = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> ele = <span class="keyword">this</span>.ele;</span><br><span class="line">   <span class="keyword">if</span>(val)&#123;</span><br><span class="line">      ele.innerHTML = val;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//返回this进行链式操作</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ele.innerHTML;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">GetId.prototype.on = <span class="function"><span class="keyword">function</span>(<span class="params">type,fn</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> ele = <span class="keyword">this</span>.ele;</span><br><span class="line">   ele.addEventListener(type,fn);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div1 = <span class="keyword">new</span> GetId(<span class="string">'id'</span>)</span><br><span class="line">div1.html(<span class="string">'&lt;p&gt;hellow world&lt;/p&gt;'</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="string">'clicked'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="11-new一个对象的过程"><a href="#11-new一个对象的过程" class="headerlink" title="11. new一个对象的过程"></a>11. new一个对象的过程</h2><ol>
<li>新创建一个空对象</li>
<li><code>this</code> 指向这个对象</li>
<li>执行代码，即对 <code>this</code> 赋值</li>
<li>返回 <code>this</code></li>
</ol>
<h2 id="12-执行上下文"><a href="#12-执行上下文" class="headerlink" title="12. 执行上下文"></a>12. 执行上下文</h2><p>   变量提升是<code>js</code>中经常会遇到的问题，它的原理离不开执行上下文。针对一段<code>script</code>，在执行之前，会生成全局执行上下文；针对一个函数，在执行之前，会生成一个函数执行上下文。即执行上下文分为全局执行上下文和函数执行上下文。<br>   执行一段代码，会创建对应的执行上下文（一个空对象），该上下文被压入执行上下文栈。然后初始化该上下文，这个阶段会创建变量对象（VO）、建立作用域链和确定<code>this</code>指向；而后进入上下文的执行阶段，这个阶段会将变量对象转换为活动对象（AO），并执行代码。执行完毕后，执行上下文会出栈等待回收。<br>   创建变量对象的时候，其参数只有<code>arguments</code>，转换为活动对象的时候发生以下事件：</p>
<ol>
<li>将函数的形参传入，并将其实参值作为初始值，若实参为空，则初始化为<code>undefined</code>。</li>
<li>将作用域内变量初始化为<code>undefined</code>，若与参数冲突则什么也不做；函数表达式与变量同等对待。</li>
<li>将函数声明初始化为<code>function</code>，若与参数或者变量冲突则覆盖。<br>变量对象转换为活动对象所产生的效果会影响变量的值，这就是变量提升现象的来源。<br><img src="http://q65s4i59e.bkt.clouddn.com/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87" alt="执行上下文图解"></li>
</ol>
<h2 id="13-this"><a href="#13-this" class="headerlink" title="13. this"></a>13. this</h2><p>   <code>this</code>要在执行时才能确认值，定义时无法确认。<code>this</code>的常见使用场景包括：</p>
<ol>
<li>作为构造函数执行；</li>
<li>作为对象属性执行；</li>
<li>作为普通函数执行；</li>
<li><code>call apply bind</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name =name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = FOO(<span class="string">'zhangsan'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   name:<span class="string">"lisi"</span>,</span><br><span class="line">   printName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>,name)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.printName();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.call apply bind</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn1.call(&#123;<span class="attr">x</span>:<span class="number">100</span>&#125;,<span class="string">'zhangsan'</span>,<span class="number">20</span>);</span><br><span class="line">fn1.apply(&#123;<span class="attr">y</span>:<span class="number">200</span>&#125;,[<span class="string">'lisi'</span>,<span class="number">30</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;.bind(&#123;<span class="attr">y</span>:<span class="number">300</span>&#125;)</span><br><span class="line">fn2(<span class="string">'wangwu'</span>,<span class="number">40</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="14-块级作用域"><a href="#14-块级作用域" class="headerlink" title="14. 块级作用域"></a>14. 块级作用域</h2><p>   <code>js</code>无块级作用域，只有函数和全局作用域。即在<code>for if</code>等语句中定义的变量在<code>{ }</code>外部依旧可以访问。<code>ES6</code>中<code>let const</code>的使用，实现了块级作用域的概念。</p>
<h2 id="15-作用域链"><a href="#15-作用域链" class="headerlink" title="15. 作用域链"></a>15. 作用域链</h2><p>   自由变量是指当前作用域中没有定义的、也不是函数的参数的变量。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到（自由变量），就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。<br>   当某个函数第一次被调用时，就会创建一个执行上下文(execution context)以及相应的作用域链，并把作用域链赋值给一个特殊的内部属性([scope])。当前执行环境的变量对象始终在作用域链的第0位。<br>   函数的作用域在函数定义的时候就决定了。这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链。当函数激活时，进入函数上下文，创建<code>VO/AO</code> 后，就会将活动对象添加到作用链的前端。</p>
<h2 id="16-闭包"><a href="#16-闭包" class="headerlink" title="16. 闭包"></a>16. 闭包</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> scope = <span class="string">"outer"</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> scope;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = outer();</span><br></pre></td></tr></table></figure>
<p>   一般来说，当某个上下文中的所有代码执行完毕后，该上下文被销毁（弹出执行上下文栈），保存在其中的所有变量和函数也随之销毁（全局执行上下文变量直到应用程序退出，如网页关闭才会被销毁）。但是像上面那种有内部函数的又有所不同，当<code>outer()</code>函数执行结束，执行上下文被销毁，但是其关联的活动对象并没有随之销毁，而是一直存在于内存中，因为该活动对象被其内部函数的作用域链所引用。<br>   闭包的使用场景：</p>
<ol>
<li>函数作为返回值</li>
<li>函数作为参数传递<br>闭包有两个作用：</li>
<li>可以读取自身函数外部的变量即自由变量（沿着作用域链寻找）。</li>
<li>让这些外部变量始终保存在内存中。<br>闭包在实践中的运用：</li>
<li>封装变量，收敛权限<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFirstLoad</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> _list = [];</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(_list.indexOf(id) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         _list.push(id);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> firstLoad = isFirstLoad();</span><br><span class="line">firstLoad(<span class="number">10</span>);<span class="comment">//true</span></span><br><span class="line">firstLoad(<span class="number">20</span>);<span class="comment">//true</span></span><br><span class="line">firstLoad(<span class="number">10</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="17-异步"><a href="#17-异步" class="headerlink" title="17. 异步"></a>17. 异步</h2><h3 id="1-同步和异步的区别"><a href="#1-同步和异步的区别" class="headerlink" title="1. 同步和异步的区别"></a>1. 同步和异步的区别</h3><p>   <code>JavaScript</code>是单线程的，所谓单线程，是指在<code>JS</code>引擎中负责解释和执行<code>JavaScript</code>代码的线程只有一个，叫它主线程。因为<code>javascript</code>是单线程的，这意味着所有的任务需要排队处理，前一个任务结束，才会执行后一个任务，如果前一个任务耗时很长，后一个任务就不得不一直等着，于是<code>JS</code>语言的设计者意识到可以把耗时任务加入一个队列，该队列是一个存储耗时程序的队列，浏览器默认<code>setTimeout</code>以及<code>ajax</code>请求这一类的方法为耗时程序（尽管有时候并不耗时），这就是任务队列的概念。<br>   同步任务和异步任务的概念：同步任务(<code>synchronous</code>)，是指在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务(<code>asynchronous</code>)，是指不进入主线程、而进入“任务队列”(<code>task queue</code>)的任务，只有等主线程任务执行完毕，任务队列才开始通知主线程请求执行任务，该任务才会进入主线程执行。<br>   回调函数就是那些会被主线程挂起来的代码，如事件绑定时的点击事件<code>$(selector).on(&#39;click&#39;,function(){})</code>中的<code>function</code>就是一个回调函数。异步任务必须指定回调函数，主线程开始执行异步任务，就是执行对应的回调函数，例如<code>ajax</code>的<code>success</code>，<code>complete</code>，<code>error</code>等也都指定了各自的回调函数。这些函数就会加入任务队列中，等待执行。<br>   具体的异步运行机制：</p>
<ol>
<li>所有的同步任务都在主线程上执行，形成一个执行栈(<code>execution context stack</code>)；</li>
<li>主线程之外，还存在一个“任务队列”(<code>task queue</code>)，只要异步任务有了运行结果，就在“任务队列”之中放置一个事件；</li>
<li>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件，那些对应的异步任务，于是结束等待状态，开始执行；</li>
<li>主线程不断重复上面的第三步进行事件循环，只要主线程空了，就会去读取“任务队列”，这就是JS的运行机制，这个过程会不断重复；<h3 id="2-异步的使用场景"><a href="#2-异步的使用场景" class="headerlink" title="2. 异步的使用场景"></a>2. 异步的使用场景</h3></li>
<li>定时任务<code>setTimeout</code>、<code>setInterval</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="number">200</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">300</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="number">400</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
上述代码中，尽管<code>setTimeout</code>的<code>time</code>延迟时间为<code>0</code>，其中的<code>function</code>也会被放入任务队列中等待下一个机会到来时执行，而不需要加入任务队列中的程序必须在任务队列的程序之前完成，因此程序的执行顺序可能和代码中的顺序不一致。</li>
<li>网络请求：<code>ajax</code>请求、动态加载<code>&lt;img&gt;</code>加载<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态ajax请求</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line">$.<span class="keyword">get</span>("/data.json",function(data)&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br><span class="line"><span class="comment">//&lt;img&gt;动态加载</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"loaded"</span>)</span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">"/xxx.png"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br></pre></td></tr></table></figure></li>
<li>事件绑定<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>).addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="string">"clicked"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br></pre></td></tr></table></figure>

















</li>
</ol>]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>js的继承</title>
    <url>/2020/02/23/js%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="js的继承"><a href="#js的继承" class="headerlink" title="js的继承"></a>js的继承</h1><p>本文转载自 <a href="https://github.com/mqyqingfeng/Blog/issues/16" target="_blank" rel="noopener">JavaScript深入之继承的多种方式和优缺点</a></p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文讲解JavaScript各种继承方式和优缺点。</p>
<p>但是注意：</p>
<p>这篇文章更像是笔记，哎，再让我感叹一句：《JavaScript高级程序设计》写得真是太好了！</p>
<h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'kevin'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()) <span class="comment">// kevin</span></span><br></pre></td></tr></table></figure>

<p>问题：</p>
<p>1.引用类型的属性被所有实例共享，举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.names = [<span class="string">'kevin'</span>, <span class="string">'daisy'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">'yayu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br></pre></td></tr></table></figure>

<p>2.在创建 Child 的实例时，不能向Parent传参</p>
<h2 id="2-借用构造函数-经典继承"><a href="#2-借用构造函数-经典继承" class="headerlink" title="2.借用构造函数(经典继承)"></a>2.借用构造函数(经典继承)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.names = [<span class="string">'kevin'</span>, <span class="string">'daisy'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">'yayu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["kevin", "daisy"]</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>1.避免了引用类型的属性被所有实例共享</p>
<p>2.可以在 Child 中向 Parent 传参</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'daisy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<p>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</p>
<h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h2><p>原型链继承和经典继承双剑合璧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line">child1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.colors); <span class="comment">// ["red", "blue", "green", "black"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'daisy'</span>, <span class="string">'20'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// daisy</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.age); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors); <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure>

<p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p>
<h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p>
<p>缺点：</p>
<p>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'kevin'</span>,</span><br><span class="line">    friends: [<span class="string">'daisy'</span>, <span class="string">'kelly'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createObj(person);</span><br><span class="line"><span class="keyword">var</span> person2 = createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">'person1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.firends.push(<span class="string">'taylor'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// ["daisy", "kelly", "taylor"]</span></span><br></pre></td></tr></table></figure>

<p>注意：修改<code>person1.name</code>的值，<code>person2.name</code>的值并未发生改变，并不是因为<code>person1</code>和<code>person2</code>有独立的 name 值，而是因为<code>person1.name = &#39;person1&#39;</code>，给<code>person1</code>添加了 name 值，并非修改了原型上的 name 值。</p>
<h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(o);</span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p>
<h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h2><p>为了方便大家阅读，在这里重复一下组合继承的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure>

<p>组合继承最大的缺点是会调用两次父构造函数。</p>
<p>一次是设置子类型实例的原型的时候：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>

<p>一次在创建子类型实例的时候：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br></pre></td></tr></table></figure>

<p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Parent.call(<span class="keyword">this</span>, name);</span><br></pre></td></tr></table></figure>

<p>在这里，我们又会调用了一次 Parent 构造函数。</p>
<p>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为<code>colors</code>，属性值为<code>[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]</code>。</p>
<p>那么我们该如何精益求精，避免这一次重复调用呢？</p>
<p>如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？</p>
<p>看看如何实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键的三步</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">F.prototype = Parent.prototype;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure>

<p>最后我们封装一下这个继承方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(parent.prototype);</span><br><span class="line">    prototype.constructor = child;</span><br><span class="line">    child.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用的时候：</span></span><br><span class="line">prototype(Child, Parent);</span><br></pre></td></tr></table></figure>

<p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p>
<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>js创建对象的方式</title>
    <url>/2020/02/23/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建js对象几种方式"><a href="#创建js对象几种方式" class="headerlink" title="创建js对象几种方式"></a>创建js对象几种方式</h1><p>本文介绍创建js对象几种方式。文章引用自 <a href="https://github.com/mqyqingfeng/Blog/issues/15" target="_blank" rel="noopener">JavaScript深入之创建对象的多种方式以及优缺点</a> 及 <a href="https://www.jianshu.com/p/72264bea94a6" target="_blank" rel="noopener">JS入门难点解析10-创建对象</a>。</p>
<h2 id="创建单个对象的方法"><a href="#创建单个对象的方法" class="headerlink" title="创建单个对象的方法"></a>创建单个对象的方法</h2><p>简单的对象创建方法，主要用于创建单个的对象。但是不适合创建多个对象。就像是手工制品，不适合量产。</p>
<h4 id="1-对象字面量"><a href="#1-对象字面量" class="headerlink" title="1.对象字面量"></a>1.对象字面量</h4><p>最简单的对象创建方法，莫过于使用对象字面量了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doll = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种写法简单干净，给人一种数据封装的感觉，是开发人员最青睐的创建对象的方法。要注意，使用对象字面量的方法来定义对象，属性名会自动转换成字符串。另外，一般地，对象字面量的最后一个属性后的逗号将忽略，但在IE7-浏览器中导致错误，所以最后一个属性后面最好不要带逗号。</p>
<h4 id="2-new-内置对象"><a href="#2-new-内置对象" class="headerlink" title="2.new + 内置对象"></a>2.new + 内置对象</h4><p>最常用的就是new操作符后跟Object构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doll = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">//如果不给构造函数传递参数可以不加括号 var doll= new Object;</span></span><br><span class="line">doll.name = <span class="string">'Nicholas'</span>;</span><br><span class="line">doll.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>当然其他内置对象还有Array，Date，RegExp，Function，基本包装类型等。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="3-Object-create"><a href="#3-Object-create" class="headerlink" title="3.Object.create()"></a>3.Object.create()</h4><p>ES5定义了一个名为Object.create()的方法，它创建一个新对象，第一个参数就是这个对象的原型，第二个可选参数用以对对象的属性进行进一步描述。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">1</span>&#125;);   <span class="comment">// o1继承了属性x和y</span></span><br><span class="line"><span class="built_in">console</span>.log(o1.x);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>可以通过传入参数null来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法。比如<code>toString()</code>和<code>valueOf()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>); <span class="comment">// o2不继承任何属性和方法</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(o1));  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(o2));  <span class="comment">// Uncaught TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>
<p>如果想创建一个普通的空对象(比如通过{}或new Object()创建的对象)，需要传入Object.prototype。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype); <span class="comment">// o3和&#123;&#125;和new Object()一样</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(o1));  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(o3));  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Object</span>.create()方法的第二个参数是属性描述符。</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(&#123;<span class="attr">z</span>:<span class="number">3</span>&#125;,&#123;</span><br><span class="line">  x:&#123;<span class="attr">value</span>:<span class="number">1</span>,<span class="attr">writable</span>: <span class="literal">false</span>,<span class="attr">enumerable</span>:<span class="literal">true</span>,<span class="attr">configurable</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">  y:&#123;<span class="attr">value</span>:<span class="number">2</span>,<span class="attr">writable</span>: <span class="literal">false</span>,<span class="attr">enumerable</span>:<span class="literal">true</span>,<span class="attr">configurable</span>:<span class="literal">true</span>&#125;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(o1.x,o1.y,o1.z);  <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>
<h2 id="创建多个对象"><a href="#创建多个对象" class="headerlink" title="创建多个对象"></a>创建多个对象</h2><p>这篇文章讲解创建对象的各种方式，以及优缺点。<br>但是注意：<br>这篇文章更像是笔记，因为《JavaScript高级程序设计》写得真是太好了！</p>
<h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a>1. 工厂模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'kevin'</span>);</span><br></pre></td></tr></table></figure>

<p>缺点：对象无法识别，因为所有的实例都指向一个原型</p>
<h3 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2. 构造函数模式"></a>2. 构造函数模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br></pre></td></tr></table></figure>

<p>优点：实例可以识别为一个特定的类型</p>
<p>缺点：每次创建实例时，每个方法都要被创建一次</p>
<h3 id="2-1-构造函数模式优化"><a href="#2-1-构造函数模式优化" class="headerlink" title="2.1 构造函数模式优化"></a>2.1 构造函数模式优化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.getName = getName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br></pre></td></tr></table></figure>

<p>优点：解决了每个方法都要被重新创建的问题</p>
<p>缺点：这叫啥封装……</p>
<h3 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3. 原型模式"></a>3. 原型模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'keivn'</span>;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>优点：方法不会重新创建</p>
<p>缺点：1. 所有的属性和方法都共享 2. 不能初始化参数</p>
<h3 id="3-1-原型模式优化"><a href="#3-1-原型模式优化" class="headerlink" title="3.1 原型模式优化"></a>3.1 原型模式优化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">'kevin'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>优点：封装性好了一点</p>
<p>缺点：重写了原型，丢失了constructor属性</p>
<h3 id="3-2-原型模式优化"><a href="#3-2-原型模式优化" class="headerlink" title="3.2 原型模式优化"></a>3.2 原型模式优化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'kevin',</span><br><span class="line">    getName: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>优点：实例可以通过constructor属性找到所属构造函数</p>
<p>缺点：原型模式该有的缺点还是有</p>
<h3 id="4-组合模式"><a href="#4-组合模式" class="headerlink" title="4. 组合模式"></a>4. 组合模式</h3><p>构造函数模式与原型模式双剑合璧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    getName: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>优点：该共享的共享，该私有的私有，使用最广泛的方式</p>
<p>缺点：有的人就是希望全部都写在一起，即更好的封装性</p>
<h3 id="4-1-动态原型模式"><a href="#4-1-动态原型模式" class="headerlink" title="4.1 动态原型模式"></a>4.1 动态原型模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>注意：使用动态原型模式时，不能用对象字面量重写原型</p>
<p>解释下为什么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype = &#123;</span><br><span class="line">            <span class="keyword">constructor</span>: Person,</span><br><span class="line">            getName: function () &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'daisy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错 并没有该方法</span></span><br><span class="line">person1.getName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注释掉上面的代码，这句是可以执行的。</span></span><br><span class="line">person2.getName();</span><br></pre></td></tr></table></figure>

<p>为了解释这个问题，假设开始执行<code>var person1 = new Person(&#39;kevin&#39;)</code>。</p>
<p>如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。</p>
<p>我们回顾下 new 的实现步骤：</p>
<ol>
<li>首先新建一个对象</li>
<li>然后将对象的原型指向 Person.prototype</li>
<li>然后 Person.apply(obj)</li>
<li>返回这个对象</li>
</ol>
<p>注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！</p>
<p>如果你就是想用字面量方式写代码，可以尝试下这种：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype = &#123;</span><br><span class="line">            <span class="keyword">constructor</span>: Person,</span><br><span class="line">            getName: function () &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'daisy'</span>);</span><br><span class="line"></span><br><span class="line">person1.getName(); <span class="comment">// kevin</span></span><br><span class="line">person2.getName();  <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure>

<h3 id="5-1-寄生构造函数模式"><a href="#5-1-寄生构造函数模式" class="headerlink" title="5.1 寄生构造函数模式"></a>5.1 寄生构造函数模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>寄生构造函数模式，我个人认为应该这样读：</p>
<p>寄生-构造函数-模式，也就是说寄生在构造函数的一种方法。</p>
<p>也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！</p>
<p>这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改Array构造函数，我们可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        values.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>);</span><br><span class="line"><span class="keyword">var</span> colors2 = SpecialArray(<span class="string">'red2'</span>, <span class="string">'blue2'</span>, <span class="string">'green2'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors);</span><br><span class="line"><span class="built_in">console</span>.log(colors.toPipedString()); <span class="comment">// red|blue|green</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors2);</span><br><span class="line"><span class="built_in">console</span>.log(colors2.toPipedString()); <span class="comment">// red2|blue2|green2</span></span><br></pre></td></tr></table></figure>

<p>你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个new，实际上两者的结果是一样的。</p>
<p>但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。</p>
<p>在可以使用其他模式的情况下，不要使用这种模式。</p>
<p>但是值得一提的是，上面例子中的循环：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    values.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以替换成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">values.push.apply(values, <span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>

<h3 id="5-2-稳妥构造函数模式"><a href="#5-2-稳妥构造函数模式" class="headerlink" title="5.2 稳妥构造函数模式"></a>5.2 稳妥构造函数模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = person(<span class="string">'kevin'</span>);</span><br><span class="line"></span><br><span class="line">person1.sayName(); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">"daisy"</span>;</span><br><span class="line"></span><br><span class="line">person1.sayName(); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure>

<p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。</p>
<p>与寄生构造函数模式有两点不同：</p>
<ol>
<li>新创建的实例方法不引用 this</li>
<li>不使用 new 操作符调用构造函数</li>
</ol>
<p>稳妥对象最适合在一些安全的环境中。</p>
<p>稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。</p>
<p>文章转载自<a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">JavaScript深入系列目录地址</a></p>]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>具有继承性的CSS样式属性</title>
    <url>/2020/02/04/%E5%85%B7%E6%9C%89%E7%BB%A7%E6%89%BF%E6%80%A7%E7%9A%84CSS%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="具有继承性的CSS样式属性"><a href="#具有继承性的CSS样式属性" class="headerlink" title="具有继承性的CSS样式属性"></a>具有继承性的CSS样式属性</h1><h2 id="1-字体系列属性"><a href="#1-字体系列属性" class="headerlink" title="1. 字体系列属性"></a>1. 字体系列属性</h2><p>font：组合字体<br>font-family：规定元素的字体系列<br>font-weight：设置字体的粗细<br>font-size：设置字体的尺寸<br>font-style：定义字体的风格<br>font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。<br>font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。<br>font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。</p>
<h2 id="2-文本系列属性"><a href="#2-文本系列属性" class="headerlink" title="2. 文本系列属性"></a>2. 文本系列属性</h2><p>text-indent：文本缩进<br>text-align：文本水平对齐<br>line-height：行高<br>word-spacing：增加或减少单词间的空白（即字间隔）<br>letter-spacing：增加或减少字符间的空白（字符间距）<br>text-transform：控制文本大小写<br>direction：规定文本的书写方向<br>color：文本颜色</p>
<h2 id="3-元素可见性"><a href="#3-元素可见性" class="headerlink" title="3. 元素可见性"></a>3. 元素可见性</h2><p>visibility</p>
<h2 id="4-表格布局属性"><a href="#4-表格布局属性" class="headerlink" title="4. 表格布局属性"></a>4. 表格布局属性</h2><p>caption-side<br>border-collapse<br>border-spacing<br>empty-cells<br>table-layout</p>
<h2 id="5-列表布局属性"><a href="#5-列表布局属性" class="headerlink" title="5. 列表布局属性"></a>5. 列表布局属性</h2><p>list-style-type<br>list-style-image<br>list-style-position<br>list-style</p>
<h2 id="6-生成内容属性"><a href="#6-生成内容属性" class="headerlink" title="6. 生成内容属性"></a>6. 生成内容属性</h2><p>quotes</p>
<h2 id="7-光标属性"><a href="#7-光标属性" class="headerlink" title="7. 光标属性"></a>7. 光标属性</h2><p>cursor</p>
<h2 id="8-页面样式属性"><a href="#8-页面样式属性" class="headerlink" title="8.页面样式属性"></a>8.页面样式属性</h2><p>page<br>page-break-inside<br>windows<br>orphans</p>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>web 无障碍</title>
    <url>/2020/02/03/web%E6%97%A0%E9%9A%9C%E7%A2%8D/</url>
    <content><![CDATA[<h1 id="web-无障碍"><a href="#web-无障碍" class="headerlink" title="web 无障碍"></a>web 无障碍</h1><p>   能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。残障人士指的是那些带有残疾或者身体不健康的用户。</p>
<h2 id="1-使用alt属性，例如："><a href="#1-使用alt属性，例如：" class="headerlink" title="1. 使用alt属性，例如："></a>1. 使用alt属性，例如：</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"person.jpg"</span>  <span class="attr">alt</span>=<span class="string">"this is a person"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>有时候浏览器会无法显示图像。具体的原因有：</p>
<ol>
<li>用户关闭了图像显示。</li>
<li>浏览器是不支持图形显示的迷你浏览器。</li>
<li>浏览器是语音浏览器（供盲人和弱视人群使用）。<br>如果使用了alt 属性，那么浏览器至少可以显示或读出有关图像的描述。</li>
</ol>
<h2 id="2-使用可调节的字体大小"><a href="#2-使用可调节的字体大小" class="headerlink" title="2. 使用可调节的字体大小"></a>2. 使用可调节的字体大小</h2><p>   使用相对的字体尺寸，这样用户就能够使用浏览器菜单来改变默认的字体尺寸。</p>]]></content>
      <categories>
        <category>html</category>
      </categories>
  </entry>
  <entry>
    <title>CSS清除浮动</title>
    <url>/2020/02/03/CSS%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="CSS清除浮动"><a href="#CSS清除浮动" class="headerlink" title="CSS清除浮动"></a>CSS清除浮动</h1><h2 id="1-什么是CSS清除浮动？"><a href="#1-什么是CSS清除浮动？" class="headerlink" title="1. 什么是CSS清除浮动？"></a>1. 什么是CSS清除浮动？</h2><p>   在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.news &#123;</span><br><span class="line">  background-color: gray;</span><br><span class="line">  border: solid 1px black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news img &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news p &#123;</span><br><span class="line">  float: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"news-pic.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>some text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-清除浮动方法"><a href="#2-清除浮动方法" class="headerlink" title="2. 清除浮动方法"></a>2. 清除浮动方法</h2><h3 id="1-使用带clear属性的空元素"><a href="#1-使用带clear属性的空元素" class="headerlink" title="1. 使用带clear属性的空元素"></a>1. 使用带clear属性的空元素</h3><p>   在浮动元素后使用一个空元素如<div class="clear"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用<br class="clear" />或<hr class="clear" />来进行清理。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.news &#123;</span><br><span class="line">  background-color: gray;</span><br><span class="line">  border: solid 1px black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news img &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news p &#123;</span><br><span class="line">  float: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.clear &#123;</span><br><span class="line">  clear: both;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"news-pic.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>some text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clear"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>优点：简单，代码少，浏览器兼容性好。<br>缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。</p>
<h3 id="2-使用CSS的overflow属性"><a href="#2-使用CSS的overflow属性" class="headerlink" title="2. 使用CSS的overflow属性"></a>2. 使用CSS的overflow属性</h3><p>   给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。<br>   在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.news &#123;</span><br><span class="line">  background-color: gray;</span><br><span class="line">  border: solid 1px black;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  *zoom: 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news img &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news p &#123;</span><br><span class="line">  float: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"news-pic.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>some text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-给浮动的元素的容器添加浮动"><a href="#3-给浮动的元素的容器添加浮动" class="headerlink" title="3. 给浮动的元素的容器添加浮动"></a>3. 给浮动的元素的容器添加浮动</h3><p>   给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。</p>
<h3 id="4-使用邻接元素处理"><a href="#4-使用邻接元素处理" class="headerlink" title="4. 使用邻接元素处理"></a>4. 使用邻接元素处理</h3><p>   什么都不做，给浮动元素后面的元素添加clear属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.news &#123;</span><br><span class="line">  background-color: gray;</span><br><span class="line">  border: solid 1px black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news img &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news p &#123;</span><br><span class="line">  float: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.content&#123;</span><br><span class="line">  clear:both;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"news-pic.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>some text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-使用CSS的-after伪元素"><a href="#5-使用CSS的-after伪元素" class="headerlink" title="5. 使用CSS的:after伪元素"></a>5. 使用CSS的:after伪元素</h3><p>   结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。<br>   给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.news &#123;</span><br><span class="line">  background-color: gray;</span><br><span class="line">  border: solid 1px black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news img &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news p &#123;</span><br><span class="line">  float: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">  content: "020"; </span><br><span class="line">  display: block; </span><br><span class="line">  height: 0; </span><br><span class="line">  clear: both; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.clearfix &#123;</span><br><span class="line">  /* 触发 hasLayout */ </span><br><span class="line">  zoom: 1; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news clearfix"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"news-pic.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>some text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>   通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格”020”或点”.”，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>   通过上面的例子，我们不难发现清除浮动的方法可以分成两类：<br>   一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。<br>   二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素，关于这一点。<br>    在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。<br>   最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。</p>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p>   <a href="https://www.cnblogs.com/ForEvErNoME/p/3383539.html" target="_blank" rel="noopener">清除浮动</a></p>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>position定位</title>
    <url>/2020/02/03/position%E5%B1%9E%E6%80%A7%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h1 id="position属性-比较"><a href="#position属性-比较" class="headerlink" title="position属性 比较"></a>position属性 比较</h1><h2 id="1-固定定位fixed"><a href="#1-固定定位fixed" class="headerlink" title="1. 固定定位fixed"></a>1. 固定定位fixed</h2><p>   元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed定位使元素的位置与文档流无关，因此不占据空间。 Fixed定位的元素和其他元素重叠。</p>
<h2 id="2-相对定位relative"><a href="#2-相对定位relative" class="headerlink" title="2. 相对定位relative"></a>2. 相对定位relative</h2><p>   如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</p>
<h2 id="3-绝对定位absolute"><a href="#3-绝对定位absolute" class="headerlink" title="3. 绝对定位absolute"></a>3. 绝对定位absolute</h2><p>   绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<code>&lt;html&gt;</code>。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。</p>
<h2 id="4-粘性定位sticky"><a href="#4-粘性定位sticky" class="headerlink" title="4. 粘性定位sticky"></a>4. 粘性定位sticky</h2><p>   元素先按照普通文档流定位，然后相对于该元素在流中的flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p>
<h2 id="5-默认定位Static"><a href="#5-默认定位Static" class="headerlink" title="5. 默认定位Static"></a>5. 默认定位Static</h2><p>   默认值。没有定位，元素出现在正常的流中（忽略top, bottom, left, right 或者 z-index 声明）。</p>
<h2 id="6-inherit"><a href="#6-inherit" class="headerlink" title="6. inherit"></a>6. inherit</h2><p>   规定应该从父元素继承position 属性的值。</p>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>垂直居中的方法</title>
    <url>/2020/02/03/css%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="垂直居中的方法"><a href="#垂直居中的方法" class="headerlink" title="垂直居中的方法"></a>垂直居中的方法</h1><h2 id="1-margin-auto法"><a href="#1-margin-auto法" class="headerlink" title="1. margin:auto法"></a>1. margin:auto法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">css:</span><br><span class="line">div&#123;</span><br><span class="line">   width: 400px;</span><br><span class="line">   height: 400px;</span><br><span class="line">   position: relative;</span><br><span class="line">   border: 1px solid #465468;</span><br><span class="line">&#125;</span><br><span class="line">img&#123;</span><br><span class="line">   position: absolute;</span><br><span class="line">   margin: auto;</span><br><span class="line">   top: 0;</span><br><span class="line">   left: 0;</span><br><span class="line">   right: 0;</span><br><span class="line">   bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">html:</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"mm.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>定位为上下左右为0，margin：0可以实现脱离文档流的居中。</p>
<h2 id="2-margin负值法"><a href="#2-margin负值法" class="headerlink" title="2. margin负值法"></a>2. margin负值法</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#379</span>;</span><br><span class="line">   <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">480px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">380px</span>;</span><br><span class="line">   <span class="attribute">background-color</span>: <span class="number">#746</span>;</span><br><span class="line">   <span class="attribute">position</span>: absolute;</span><br><span class="line">   <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">margin-top</span>: -<span class="number">190px</span>; <span class="comment">/*height的一半*/</span></span><br><span class="line">   <span class="attribute">margin-left</span>: -<span class="number">240px</span>; <span class="comment">/*width的一半*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：其实这里也可以将marin-top和margin-left负值替换成，<br>transform：translateX(-50%)和transform：translateY(-50%)</p>
<h2 id="3-table-cell（未脱离文档流的）"><a href="#3-table-cell（未脱离文档流的）" class="headerlink" title="3. table-cell（未脱离文档流的）"></a>3. table-cell（未脱离文档流的）</h2><p>   设置父元素的display:table-cell,并且vertical-align:middle，这样子元素可以实现垂直居中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">css</span>:</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#555</span>;</span><br><span class="line">   <span class="attribute">display</span>: table-cell;</span><br><span class="line">   <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">   <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">   <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-利用flex"><a href="#4-利用flex" class="headerlink" title="4. 利用flex"></a>4. 利用flex</h2><p>将父元素设置为display:flex，并且设置align-items:center;justify-content:center;</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#546461</span>;</span><br><span class="line">   <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">   <span class="attribute">display</span>: flex;</span><br><span class="line">   <span class="attribute">-webkit-align-items</span>: center;</span><br><span class="line">   <span class="attribute">align-items</span>: center;</span><br><span class="line">   <span class="attribute">-webkit-justify-content</span>: center;</span><br><span class="line">   <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#458761</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>websocket介绍</title>
    <url>/2020/02/01/WebSocket%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="websocket-知识介绍"><a href="#websocket-知识介绍" class="headerlink" title="websocket 知识介绍"></a>websocket 知识介绍</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>   WebSocket是 HTML5 中的协议，支持持久连续连接，而 http 协议不支持持久性连接。HTTP1.0 和 HTTP1.1 都不支持持久性的链接，HTTP1.1 中的 keep-alive，将多个 http 请求合并为 1 个</p>
<h2 id="2-WebSocket的优点"><a href="#2-WebSocket的优点" class="headerlink" title="2. WebSocket的优点"></a>2. WebSocket的优点</h2><p>   HTTP的生命周期通过 Request 来界定，也就是 Request 一个 Response，那么在 HTTP1.0 协议中，这次 http 请求就结束了。在 HTTP1.1中进行了改进，是的有一个 connection：Keep-alive，也就是说，在一个 http 连接中，可以发送多个 Request，接收多个 Response。但是必须记住，在 http 中一个 Request 只能对应有一个 Response，而且这个 Response 是被动的，不能主动发起。<br>   WebSocket 是基于 HTTP 协议的，或者说借用了HTTP 协议来完成一部分握手，在握手阶段与http是相同的。我们来看一个 websocket 握手协议的实现，基本是 2 个属性：upgrade 和 connection。</p>
<p>基本请求如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure>
<p>多了下面2个属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Upgrade:webSocket</span><br><span class="line">Connection:Upgrade</span><br></pre></td></tr></table></figure>
<p>告诉服务器发送的是websocket</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>html</category>
      </categories>
  </entry>
  <entry>
    <title>http与https介绍</title>
    <url>/2020/02/01/http%E4%B8%8Ehttps/</url>
    <content><![CDATA[<h1 id="http与https介绍"><a href="#http与https介绍" class="headerlink" title="http与https介绍"></a>http与https介绍</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>   http 即超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。https 是以安全为目标的HTTP通道，https 的 SSL 加密是在传输层实现的。简单讲是HTTP的安全版，即 HTTP下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要SSL。https 协议的主要作用是建立一个信息安全通道，来确保数组的传输，确保网站的真实性。<br>   SSL(Secure Sockets Layer ，安全套接层)，及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS 与 SSL 在传输层与应用层之间对网络连接进行加密。<br>   下表介绍互联网加密协议历史：<br>|时间|版本|<br>|:–:|:–:|<br>|1994年|NetScape 公司设计了 SSL 协议的1.0版，但是未发布。|<br>|1995年|NetScape 公司发布 SSL 2.0版，很快发现有严重漏洞。|<br>|1996年|SSL 3.0 版问世，得到大规模应用。|<br>|1999年|互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL 的升级版 TLS 1.0 版。|<br>|2006年|TLS 升级为 TLS 1.1 版。|<br>|2008年|TLS 升级为 TLS 1.2 版。最新的变动是2011年 TLS 1.2 的修订版。|<br>   目前，应用最广泛的是TLS 1.0和SSL 3.0。主流浏览器都已经实现了 TLS 1.2 的支持。TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3。所谓的 HTTPS 其实是 “HTTP over SSL” 或 “HTTP over TLS”，它是 HTTP 与 SSL/TSL 的结合使用而已。SSL/TLS协议的基本过程：</p>
<ol>
<li><p>客户端发出请求。<br>客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello 请求。在这一步，客户端主要向服务器提供以下信息：支持的协议版本，比如 TLS 1.0 版。一个客户端生成的随机数，稍后用于生成”对话密钥”。支持的加密方法，比如RSA公钥加密。支持的压缩方法。</p>
</li>
<li><p>服务器回应。<br>服务器收到客户端请求后，向客户端发出回应，这叫做 SeverHello。服务器的回应包含以下内容：确认使用的加密通信协议版本，比如 TLS 1.0 版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。一个服务器生成的随机数，稍后用于生成”对话密钥”。确认使用的加密方法，比如 RSA 公钥加密。服务器证书。</p>
</li>
<li><p>客户端回应。<br>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息：一个随机数。该随机数用服务器公钥加密，防止被窃听。编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p>
</li>
<li><p>服务器回应<br>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息：编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p>
</li>
<li><p>双方采用”对话密钥”进行加密通信。<br>(来自 <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">阮一峰–SSL/TLS协议运行机制</a> 。)<br>下表介绍 http 协议的版本及发布时间。</p>
<table>
<thead>
<tr>
<th align="center">协议版本</th>
<th align="center">时间</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HTTP/0.9</td>
<td align="center">1991</td>
<td align="center">它只有一个命令 GET，没有 HEADER 等描述数据的信息，服务器发送完内容之后，就关闭 TCP 连接。</td>
</tr>
<tr>
<td align="center">HTTP/1.0</td>
<td align="center">1996</td>
<td align="center">增加了很多命令，比如：POST、PUT、HEADER 这些命令。 增加了status code 和 header 相关的内容 。加了多字符集支持、多部分发送、权限、缓存等相关的内容。</td>
</tr>
<tr>
<td align="center">HTTP/1.1</td>
<td align="center">1999</td>
<td align="center">支持了持久连接。增加了pipeline。 增加了 HTTP 的头 host 和其他一些命令。</td>
</tr>
<tr>
<td align="center">HTTP/2</td>
<td align="center">2015</td>
<td align="center">头信息的压缩。推送的功能。</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="2-http-和-https-的区别"><a href="#2-http-和-https-的区别" class="headerlink" title="2. http 和 https 的区别"></a>2. http 和 https 的区别</h2><p>   http 传输的数据都是未加密的，也就是明文的，NetScape 公司设置了SSL协议来对 http 协议传输的数据进行加密处理，简单来说 https 协议是由 http 和 ssl 协议构建的可进行加密传输和身份认证的网络协议，比 http 协议的安全性更高。<br>主要的区别如下表：<br>|区别|<br>|:—|<br>|Https 协议需要 ca 证书，费用较高。|<br>|http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。|<br>|使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443。|<br>|http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。|<br>   CA (Certificate Authority)，也叫“证书授权中心”。证书即 “digital certificate” 或 “public key certificate”。CA 是负责管理和签发证书的第三方机构，它必须具有足够的权威性；它可以是一个公认的权威的企业，也可以是企业自身。企业内部系统一般都使用企业自身的认证系统。CA 认证流程包括以下主要步骤。</p>
<ol>
<li>HTTPS 通信双方的服务器端向 CA 机构申请证书，CA 机构下发根证书、服务端证书及私钥给申请者；</li>
<li>HTTPS 通信双方的客户端向 CA 机构申请证书，CA机构下发根证书、客户端证书及私钥给申请者；</li>
<li>客户端向服务器端发起请求，服务端下发服务端证书给客户端。客户端接收到证书后，通过私钥解密证书，并利用服务器端证书中的公钥认证证书信息比较证书里的消息，例如域名和公钥与服务器刚刚发送的相关消息是否一致，如果一致，则客户端认为这个服务器的合法身份；</li>
<li>客户端发送客户端证书给服务器端，服务端接收到证书后，通过私钥解密证书，获得客户端的证书公钥，并用该公钥认证证书信息，确认客户端是否合法；</li>
<li>客户端通过随机秘钥加密信息，并发送加密后的信息给服务端。服务器端和客户端协商好加密方案后，客户端会产生一个随机的秘钥，客户端通过协商好的加密方案，加密该随机秘钥，并发送该随机秘钥到服务器端。服务器端接收这个秘钥后，双方通信的所有内容都都通过该随机秘钥加密；</li>
</ol>
<h2 id="3-https-协议的工作原理"><a href="#3-https-协议的工作原理" class="headerlink" title="3. https 协议的工作原理"></a>3. https 协议的工作原理</h2><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤。<br>|过程|<br>|:—-|<br>|客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。|<br>|web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回给客户端。|<br>|客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。|<br>|客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。|<br>|web 服务器通过自己的私钥解密出会话密钥。|<br>|web 服务器通过会话密钥加密与客户端之间的通信。|</p>
<h2 id="4-https-协议的优点"><a href="#4-https-协议的优点" class="headerlink" title="4. https 协议的优点"></a>4. https 协议的优点</h2><p>   使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高”。</p>
<h2 id="5-https-协议的缺点"><a href="#5-https-协议的缺点" class="headerlink" title="5. https 协议的缺点"></a>5. https 协议的缺点</h2><p>   https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20% 的耗电。https 缓存不如 http 高效，会增加数据开销。SSL 证书也需要钱，功能越强大的证书费用越高。SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPv4 资源支持不了这种消耗。</p>
<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ol>
<li><a href="https://www.nowcoder.com/tutorial/96/4700c6f1f3334c9191a38406002efa65" target="_blank" rel="noopener">牛客网面经</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">阮一峰–SSL/TLS协议运行机制</a></li>
</ol>]]></content>
      <categories>
        <category>html</category>
      </categories>
  </entry>
  <entry>
    <title>html标签</title>
    <url>/2020/01/31/html%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="HTML的基本标签"><a href="#HTML的基本标签" class="headerlink" title="HTML的基本标签"></a>HTML的基本标签</h1><hr>
<p>本文根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element" target="_blank" rel="noopener">html元素参考</a> 整理得来，作为笔记使用。</p>
<ol>
<li><p>根元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> 、<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">html</td>
<td align="center">HTML文档的根。</td>
</tr>
<tr>
<td align="center">body</td>
<td align="center">分区根元素，表示文档的内容。</td>
</tr>
</tbody></table>
</li>
<li><p>文档元数据<br>元数据含有页面的相关信息，包括样式、脚本及数据，能帮助一些软件（例如 <a href="https://developer.mozilla.org/en-US/docs/Glossary/search_engine" target="_blank" rel="noopener">搜索引擎</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/Browser" target="_blank" rel="noopener">浏览器</a> 等等）更好地运用和渲染页面。对于样式和脚本的元数据，可以直接在网页里定义，也可以链接到包含相关信息的外部文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>、<span class="tag">&lt;<span class="name">title</span>&gt;</span>、<span class="tag">&lt;<span class="name">base</span>&gt;</span>、<span class="tag">&lt;<span class="name">link</span>&gt;</span>、<span class="tag">&lt;<span class="name">meta</span>&gt;</span>、<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">head</td>
<td align="center">关于文档元数据的一个集合，包括脚本或样式表的链接或内容。</td>
</tr>
<tr>
<td align="center">title</td>
<td align="center">定义文档的标题，将显示在浏览器的标题栏或标签页上。该元素只能包含文本，包含的标签不会被解释。</td>
</tr>
<tr>
<td align="center">base</td>
<td align="center">定义页面上相对 URL 的基准 URL。</td>
</tr>
<tr>
<td align="center">link</td>
<td align="center">用于链接外部的 CSS 到该文档。</td>
</tr>
<tr>
<td align="center">meta</td>
<td align="center">定义其他 HTML 元素无法描述的元数据。</td>
</tr>
<tr>
<td align="center">style</td>
<td align="center">用于内联 CSS。</td>
</tr>
</tbody></table>
</li>
<li><p>内容分区<br>内容分区元素可以将内容从逻辑上进行组织划分，来为页面内容创建明确的大纲，以便区分各个章节的内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>、<span class="tag">&lt;<span class="name">nav</span>&gt;</span>、<span class="tag">&lt;<span class="name">section</span>&gt;</span>、<span class="tag">&lt;<span class="name">aside</span>&gt;</span> 、<span class="tag">&lt;<span class="name">footer</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>~<span class="tag">&lt;<span class="name">h6</span>&gt;</span> 、<span class="tag">&lt;<span class="name">article</span>&gt;</span> 、<span class="tag">&lt;<span class="name">address</span>&gt;</span>、<span class="tag">&lt;<span class="name">hgroup</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">header</td>
<td align="center">表示一组引导性的帮助。</td>
</tr>
<tr>
<td align="center">nav</td>
<td align="center">导航。</td>
</tr>
<tr>
<td align="center">section</td>
<td align="center">表示文档中的一个区域（或节），通过是否含一个标题作为子节点来辨识。</td>
</tr>
<tr>
<td align="center">aside</td>
<td align="center">表示与其余页面无关的内容部分。</td>
</tr>
<tr>
<td align="center">footer</td>
<td align="center">表示最近一个章节内容或者根节点元素的页脚。</td>
</tr>
<tr>
<td align="center">h</td>
<td align="center">标题。</td>
</tr>
<tr>
<td align="center">article</td>
<td align="center">表示文档、页面、应用或网站中的独立结构。</td>
</tr>
<tr>
<td align="center">address</td>
<td align="center">地址信息。</td>
</tr>
</tbody></table>
</li>
<li><p>文本内容<br>使用 HTML 文本内容元素来组织在开标签 <code>&lt;body&gt;</code> 和闭标签 <code>&lt;/body&gt;</code> 里的块或章节的内容。这些元素能标识内容的宗旨或结构，而这对于 accessibility 和 SEO 很重要。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>、<span class="tag">&lt;<span class="name">div</span>&gt;</span>、<span class="tag">&lt;<span class="name">p</span>&gt;</span>、<span class="tag">&lt;<span class="name">pre</span>&gt;</span>、<span class="tag">&lt;<span class="name">ol</span>&gt;</span>、</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>、<span class="tag">&lt;<span class="name">li</span>&gt;</span>、<span class="tag">&lt;<span class="name">dl</span>&gt;</span> 、<span class="tag">&lt;<span class="name">dt</span>&gt;</span>、<span class="tag">&lt;<span class="name">dd</span>&gt;</span>、<span class="tag">&lt;<span class="name">figure</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>、<span class="tag">&lt;<span class="name">blockquote</span>&gt;</span> 、<span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">main</td>
<td align="center">文档<code>&lt;body&gt;</code>或应用的主体部分。</td>
</tr>
<tr>
<td align="center">div</td>
<td align="center">文档分区元素， 通用型流内容容器。</td>
</tr>
<tr>
<td align="center">p</td>
<td align="center">段落。</td>
</tr>
<tr>
<td align="center">pre</td>
<td align="center">预定义格式文本。</td>
</tr>
<tr>
<td align="center">ol</td>
<td align="center">有序列表。</td>
</tr>
<tr>
<td align="center">ul</td>
<td align="center">无序列表。</td>
</tr>
<tr>
<td align="center">li</td>
<td align="center">列表条目元素。</td>
</tr>
<tr>
<td align="center">dl</td>
<td align="center">描述列表元素。</td>
</tr>
<tr>
<td align="center">dt</td>
<td align="center">术语定义元素。</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="center">描述元素，描述列表<code>&lt;dl&gt;</code>的子元素，<code>&lt;dd&gt;</code>与 <code>&lt;dt&gt;</code> 一起用。</td>
</tr>
<tr>
<td align="center">figure</td>
<td align="center">代表一段独立的内容, 经常与说明(caption) <code>&lt;figcaption&gt;</code> 配合使用。</td>
</tr>
<tr>
<td align="center">figcaption</td>
<td align="center">图片说明/标题，于描述其父节点 <code>&lt;figure&gt;</code> 元素里的其他数据。</td>
</tr>
<tr>
<td align="center">blockquote</td>
<td align="center">HTML 块级引用元素。</td>
</tr>
<tr>
<td align="center">hr</td>
<td align="center">表示段落级元素之间的主题转换，视觉上看是水平线。</td>
</tr>
</tbody></table>
</li>
<li><p>内联文本语义<br>使用 HTML 内联文本语义（Inline text semantics）定义一个单词、一行内容，或任意文字的语义、结构或样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>、<span class="tag">&lt;<span class="name">a</span>&gt;</span>、<span class="tag">&lt;<span class="name">strong</span>&gt;</span>、<span class="tag">&lt;<span class="name">em</span>&gt;</span>、<span class="tag">&lt;<span class="name">q</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span>、<span class="tag">&lt;<span class="name">mark</span>&gt;</span>、<span class="tag">&lt;<span class="name">code</span>&gt;</span>、<span class="tag">&lt;<span class="name">abbr</span>&gt;</span>、<span class="tag">&lt;<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bdi</span>&gt;</span>、<span class="tag">&lt;<span class="name">bdo</span>&gt;</span>、<span class="tag">&lt;<span class="name">sub</span>&gt;</span>、<span class="tag">&lt;<span class="name">sup</span>&gt;</span>、<span class="tag">&lt;<span class="name">time</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>、<span class="tag">&lt;<span class="name">u</span>&gt;</span>、<span class="tag">&lt;<span class="name">cite</span>&gt;</span>、<span class="tag">&lt;<span class="name">data</span>&gt;</span>、<span class="tag">&lt;<span class="name">kbd</span>&gt;</span>、<span class="tag">&lt;<span class="name">nobr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s</span>&gt;</span>、<span class="tag">&lt;<span class="name">samp</span>&gt;</span>、<span class="tag">&lt;<span class="name">tt</span>&gt;</span>、<span class="tag">&lt;<span class="name">var</span>&gt;</span>、<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>、<span class="tag">&lt;<span class="name">rp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rt</span>&gt;</span>、<span class="tag">&lt;<span class="name">rtc</span>&gt;</span>、<span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">kbd</td>
<td align="center">表示用户输入。</td>
</tr>
<tr>
<td align="center">span</td>
<td align="center">通用行内容器。</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">超链接。</td>
</tr>
<tr>
<td align="center">strong</td>
<td align="center">粗体显示。</td>
</tr>
<tr>
<td align="center">em</td>
<td align="center">标记出需要用户着重阅读的内容，可通过嵌套加深着重程度。</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center">短的引用文本。</td>
</tr>
<tr>
<td align="center">br</td>
<td align="center">换行。</td>
</tr>
<tr>
<td align="center">mark</td>
<td align="center">代表突出显示的文字，可以用来显示搜索引擎搜索后关键词。</td>
</tr>
<tr>
<td align="center">code</td>
<td align="center">呈现一段计算机代码。</td>
</tr>
<tr>
<td align="center">abbr</td>
<td align="center">缩写，并可选择提供一个完整的描述。</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">提醒注意，样式和粗体类似（不要用于显示粗体，用css font-weight来创建粗体）。</td>
</tr>
<tr>
<td align="center">bdi</td>
<td align="center">双向隔离元素。</td>
</tr>
<tr>
<td align="center">bdo</td>
<td align="center">双向覆盖元素。</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">排低文本。</td>
</tr>
<tr>
<td align="center">sup</td>
<td align="center">排高文本。</td>
</tr>
<tr>
<td align="center">time</td>
<td align="center">时间。</td>
</tr>
<tr>
<td align="center">i</td>
<td align="center">区分普通文本的一系列文本，内容通常以斜体显示。</td>
</tr>
<tr>
<td align="center">u</td>
<td align="center">使文本在其内容的基线下的一行呈现下划线。</td>
</tr>
<tr>
<td align="center">cite</td>
<td align="center">表示一个作品的引用。</td>
</tr>
<tr>
<td align="center">data</td>
<td align="center">将一个指定内容和机器可读的翻译联系在一起。</td>
</tr>
<tr>
<td align="center">dfn</td>
<td align="center">表示术语的一个定义。</td>
</tr>
<tr>
<td align="center">kbd</td>
<td align="center">表示用户输入。</td>
</tr>
<tr>
<td align="center">nobr</td>
<td align="center">阻止文本自动拆分成新行，不应该使用，应该使用css属性。</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">删除线，提倡使用 <code>&lt;del&gt;</code> 和 <code>&lt;ins&gt;</code> 元素。</td>
</tr>
<tr>
<td align="center">samp</td>
<td align="center">标识计算机程序输出。</td>
</tr>
<tr>
<td align="center">tt</td>
<td align="center">电报文本元素。</td>
</tr>
<tr>
<td align="center">var</td>
<td align="center">表示变量的名称，或者由用户提供的值。</td>
</tr>
<tr>
<td align="center">wbr</td>
<td align="center">一个文本中的位置，其中浏览器可以选择来换行。</td>
</tr>
<tr>
<td align="center">rp</td>
<td align="center">用于为那些不能使用<code>&lt;ruby&gt;</code>元素展示 ruby 注解的浏览器，提供随后的圆括号。</td>
</tr>
<tr>
<td align="center">rt</td>
<td align="center">用于描述东亚字符的发音。</td>
</tr>
<tr>
<td align="center">rtc</td>
<td align="center">包含文字的语义注解。</td>
</tr>
<tr>
<td align="center">ruby</td>
<td align="center">被用来展示东亚文字注音或字符注释。</td>
</tr>
</tbody></table>
</li>
<li><p>图片和多媒体<br>HTML 支持各种多媒体资源，例如图像、音频和视频。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span>、<span class="tag">&lt;<span class="name">audio</span>&gt;</span>、<span class="tag">&lt;<span class="name">video</span>&gt;</span>、<span class="tag">&lt;<span class="name">track</span>&gt;</span>、<span class="tag">&lt;<span class="name">map</span>&gt;</span>、<span class="tag">&lt;<span class="name">area</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">img</td>
<td align="center">图片。</td>
</tr>
<tr>
<td align="center">audio</td>
<td align="center">音频内容。</td>
</tr>
<tr>
<td align="center">video</td>
<td align="center">视频内容。</td>
</tr>
<tr>
<td align="center">track</td>
<td align="center">被当作媒体元素 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 的子元素来使用。</td>
</tr>
<tr>
<td align="center">map</td>
<td align="center">与 <code>&lt;area&gt;</code> 属性一起使用来定义一个图像映射(一个可点击的链接区域)。</td>
</tr>
<tr>
<td align="center">area</td>
<td align="center">在图片上定义一个热点区域，可以关联一个超链接。<code>&lt;area&gt;</code>元素仅在<code>&lt;map&gt;</code>元素内部使用。</td>
</tr>
</tbody></table>
</li>
<li><p>内嵌内容<br>除了常规的多媒体内容，HTML 可以包括各种其他的内容，即使它并不容易交互。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span>&gt;</span>、<span class="tag">&lt;<span class="name">embed</span>&gt;</span>、<span class="tag">&lt;<span class="name">object</span>&gt;</span> 、<span class="tag">&lt;<span class="name">param</span>&gt;</span>、<span class="tag">&lt;<span class="name">picture</span>&gt;</span>、<span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">iframe</td>
<td align="center">表示嵌套的浏览上下文，有效地将另一个HTML页面嵌入到当前页面中。</td>
</tr>
<tr>
<td align="center">embel</td>
<td align="center">将外部内容嵌入文档中的指定位置。</td>
</tr>
<tr>
<td align="center">object</td>
<td align="center">表示引入一个外部资源。</td>
</tr>
<tr>
<td align="center">param</td>
<td align="center">定义了<code>&lt;object&gt;</code>的参数。</td>
</tr>
<tr>
<td align="center">picture</td>
<td align="center">容器，用来为其内部特定的 <code>&lt;img&gt;</code> 元素提供多样的 <code>&lt;source&gt;</code> 元素。</td>
</tr>
<tr>
<td align="center">source</td>
<td align="center">资源。</td>
</tr>
</tbody></table>
</li>
<li><p>脚本<br>为了创建动态内容和 Web 应用程序，HTML 支持使用脚本语言，最突出的就是 JavaScript。某些元素用于支持此功能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span>&gt;</span>、<span class="tag">&lt;<span class="name">noscript</span>&gt;</span>、<span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">canvas</td>
<td align="center">通过脚本（通常是JavaScript）绘制图形。</td>
</tr>
<tr>
<td align="center">noscript</td>
<td align="center">替代未执行脚本。</td>
</tr>
<tr>
<td align="center">script</td>
<td align="center">用于嵌入或引用可执行脚本。</td>
</tr>
</tbody></table>
</li>
<li><p>编辑标识</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>、<span class="tag">&lt;<span class="name">ins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">del</td>
<td align="center">表示一些被从文档中删除的文字内容。</td>
</tr>
<tr>
<td align="center">ins</td>
<td align="center">定义已经被插入文档中的文本。</td>
</tr>
</tbody></table>
</li>
<li><p>表格内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span>、<span class="tag">&lt;<span class="name">caption</span>&gt;</span>、<span class="tag">&lt;<span class="name">thead</span>&gt;</span>、<span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tfoot</span>&gt;</span>、<span class="tag">&lt;<span class="name">tr</span>&gt;</span>、<span class="tag">&lt;<span class="name">col</span>&gt;</span><span class="tag">&lt;<span class="name">colgroup</span>&gt;</span>、<span class="tag">&lt;<span class="name">th</span>&gt;</span>、<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">table</td>
<td align="center">表格。</td>
</tr>
<tr>
<td align="center">caption</td>
<td align="center">表格的标题，通常作为 <code>&lt;table&gt;</code> 的第一个子元素出现。</td>
</tr>
<tr>
<td align="center">thead</td>
<td align="center">表格页眉。</td>
</tr>
<tr>
<td align="center">tbody</td>
<td align="center">表格主体。</td>
</tr>
<tr>
<td align="center">tfoot</td>
<td align="center">表格页脚。</td>
</tr>
<tr>
<td align="center">tr</td>
<td align="center">行。</td>
</tr>
<tr>
<td align="center">col</td>
<td align="center">列， 通常位于<code>&lt;colgroup&gt;</code>元素内。</td>
</tr>
<tr>
<td align="center">colgroup</td>
<td align="center">表格列组。</td>
</tr>
<tr>
<td align="center">th</td>
<td align="center">表头。</td>
</tr>
<tr>
<td align="center">td</td>
<td align="center">表格单元。</td>
</tr>
</tbody></table>
</li>
<li><p>表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span> 、<span class="tag">&lt;<span class="name">input</span>&gt;</span>、<span class="tag">&lt;<span class="name">textarea</span>&gt;</span> 、<span class="tag">&lt;<span class="name">label</span>&gt;</span>、<span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span>&gt;</span>、<span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>、<span class="tag">&lt;<span class="name">legend</span>&gt;</span>、<span class="tag">&lt;<span class="name">meter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optgroup</span>&gt;</span>、<span class="tag">&lt;<span class="name">option</span>&gt;</span>、<span class="tag">&lt;<span class="name">output</span>&gt;</span>、<span class="tag">&lt;<span class="name">progress</span>&gt;</span>、<span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">form</td>
<td align="center">表单。</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">输入域。</td>
</tr>
<tr>
<td align="center">textarea</td>
<td align="center">多行文本域。</td>
</tr>
<tr>
<td align="center">label</td>
<td align="center">标题。</td>
</tr>
<tr>
<td align="center">button</td>
<td align="center">按钮。</td>
</tr>
<tr>
<td align="center">datalist</td>
<td align="center">包含了一组<code>&lt;option&gt;</code>元素,这些元素表示其它表单控件可选值。</td>
</tr>
<tr>
<td align="center">fieldset</td>
<td align="center">一组相关的表单元素，并使用外框包含起。</td>
</tr>
<tr>
<td align="center">legend</td>
<td align="center">表示它的父元素<code>&lt;fieldset&gt;</code>的内容的标题。</td>
</tr>
<tr>
<td align="center">meter</td>
<td align="center">显示已知范围的标量值或者分数值。</td>
</tr>
<tr>
<td align="center">optgroup</td>
<td align="center">一个 <code>&lt;select&gt;</code>元素中的一组选项。</td>
</tr>
<tr>
<td align="center">option</td>
<td align="center">用于定义在<code>&lt;select&gt;</code>,  <code>&lt;optgroup&gt;</code>或<code>&lt;datalist&gt;</code>元素中包含的项。</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">表示计算或用户操作的结果。</td>
</tr>
<tr>
<td align="center">progress</td>
<td align="center">进度条。</td>
</tr>
<tr>
<td align="center">select</td>
<td align="center">选项菜单。</td>
</tr>
</tbody></table>
</li>
<li><p>交互元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span>、<span class="tag">&lt;<span class="name">summary</span>&gt;</span>、<span class="tag">&lt;<span class="name">dialog</span>&gt;</span>、<span class="tag">&lt;<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">details</td>
<td align="center">创建一个挂件，仅在被切换成展开状态时，它才会显示内含的信息。</td>
</tr>
<tr>
<td align="center">summary</td>
<td align="center">用作一个<code>&lt;details&gt;</code>元素的一个内容的摘要，标题或图例。</td>
</tr>
<tr>
<td align="center">dialog</td>
<td align="center">对话框。</td>
</tr>
<tr>
<td align="center">menu</td>
<td align="center">菜单。</td>
</tr>
</tbody></table>
</li>
<li><p>Web 组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span>、<span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">slot</td>
<td align="center">web 组件技术的一部分，<code>&lt;slot&gt;</code>是 web 组件的一个占位符。</td>
</tr>
<tr>
<td align="center">template</td>
<td align="center">用于保存客户端内容的机制。</td>
</tr>
</tbody></table>
</li>
<li><p>过时的和弃用的元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">acronym</span>&gt;</span>、<span class="tag">&lt;<span class="name">applet</span>&gt;</span>、<span class="tag">&lt;<span class="name">basefont</span>&gt;</span>、<span class="tag">&lt;<span class="name">bgsound</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">big</span>&gt;</span>、<span class="tag">&lt;<span class="name">blink</span>&gt;</span>、<span class="tag">&lt;<span class="name">center</span>&gt;</span>、<span class="tag">&lt;<span class="name">command</span>&gt;</span>、<span class="tag">&lt;<span class="name">content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dir</span>&gt;</span>、<span class="tag">&lt;<span class="name">element</span>&gt;</span>、<span class="tag">&lt;<span class="name">font</span>&gt;</span>、<span class="tag">&lt;<span class="name">frame</span>&gt;</span>、<span class="tag">&lt;<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span>&gt;</span>、<span class="tag">&lt;<span class="name">isindex</span>&gt;</span>、<span class="tag">&lt;<span class="name">keygen</span>&gt;</span>、<span class="tag">&lt;<span class="name">listing</span>&gt;</span>、<span class="tag">&lt;<span class="name">marquee</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menuitem</span>&gt;</span>、<span class="tag">&lt;<span class="name">multicol</span>&gt;</span>、<span class="tag">&lt;<span class="name">nextid</span>&gt;</span>、<span class="tag">&lt;<span class="name">nobr</span>&gt;</span>、<span class="tag">&lt;<span class="name">noembed</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noframes</span>&gt;</span>、<span class="tag">&lt;<span class="name">plaintext</span>&gt;</span>、<span class="tag">&lt;<span class="name">spacer</span>&gt;</span>、<span class="tag">&lt;<span class="name">strike</span>&gt;</span>、<span class="tag">&lt;<span class="name">shadow</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tt</span>&gt;</span>、<span class="tag">&lt;<span class="name">xmp</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>]]></content>
      <categories>
        <category>html</category>
      </categories>
  </entry>
  <entry>
    <title>html概述</title>
    <url>/2020/01/30/html%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="html基础"><a href="#html基础" class="headerlink" title="html基础"></a>html基础</h1><hr>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>   超文本标记语言（HyperText Markup Language，HTML）是一种用于创建网页的标准标记语言。所谓标记语言就是指一套标记标签 (markup tag)，HTML 文档使用标记标签来描述网页，一个文档包含了HTML 标签及文本内容。<br>   HTML 文档一般通过Web浏览器（如Chrome，Internet Explorer，Firefox，Safari等）进行解析并显示为网页。文件后缀名为<code>.html</code>或者<code>.htm</code>，这两种都是静态网页文件的扩展名，扩展名可以互相更换而在打开时不会引起错误。出于一致性和明确性考虑,建议使用<code>.html</code>作为后缀名。<br>   HTML 标签是由尖括号包围的关键词，比如 <code>&lt;html&gt;</code>。HTML 标签通常是成对出现的，比如<code>&lt;b&gt;</code> 和<code>&lt;/b&gt;</code>。标签对中的第一个标签是开始标签，第二个标签是结束标签。</p>
<h2 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-实例说明"><a href="#3-实例说明" class="headerlink" title="3.实例说明"></a>3.实例说明</h2><p>   <code>&lt;!DOCTYPE html&gt;</code> 声明文档为 HTML5 文档。<br>   <code>&lt;html&gt;</code> 元素是 HTML 页面的根元素。<br>   <code>&lt;head&gt;</code> 元素包含了文档的元（meta）数据，如 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code> 定义网页编码格式为 <code>utf-8</code>。<br>   <code>&lt;body&gt;</code> 元素包含了可见的页面内容。</p>
<h2 id="4-版本"><a href="#4-版本" class="headerlink" title="4.版本"></a>4.版本</h2><h3 id="4-1-版本发布时间"><a href="#4-1-版本发布时间" class="headerlink" title="4-1.版本发布时间"></a>4-1.版本发布时间</h3><table>
<thead>
<tr>
<th align="center">版本</th>
<th align="center">发布时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HTML</td>
<td align="center">1991</td>
</tr>
<tr>
<td align="center">HTML+</td>
<td align="center">1993</td>
</tr>
<tr>
<td align="center">HTML 2.0</td>
<td align="center">1995</td>
</tr>
<tr>
<td align="center">HTML 3.2</td>
<td align="center">1997</td>
</tr>
<tr>
<td align="center">HTML 4.01</td>
<td align="center">1999</td>
</tr>
<tr>
<td align="center">XHTML 1.0</td>
<td align="center">2000</td>
</tr>
<tr>
<td align="center">HTML5</td>
<td align="center">2012</td>
</tr>
<tr>
<td align="center">XHTML5</td>
<td align="center">2013</td>
</tr>
</tbody></table>
<h3 id="4-2-版本声明"><a href="#4-2-版本声明" class="headerlink" title="4-2.版本声明"></a>4-2.版本声明</h3><p>   HTML5</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>   HTML 4.01</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>XHTML 1.0</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5.参考链接"></a>5.参考链接</h2><p>   <a href="https://www.runoob.com/html/html-tutorial.html" target="_blank" rel="noopener">菜鸟教程–HTML 教程</a></p>]]></content>
      <categories>
        <category>html</category>
      </categories>
  </entry>
  <entry>
    <title>项目环境搭建与初始化</title>
    <url>/2020/01/30/%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="项目环境搭建与初始化"><a href="#项目环境搭建与初始化" class="headerlink" title="项目环境搭建与初始化"></a>项目环境搭建与初始化</h1><hr>
<h2 id="1-工具安装和环境搭建（nodejs-npm-mongodb）"><a href="#1-工具安装和环境搭建（nodejs-npm-mongodb）" class="headerlink" title="1. 工具安装和环境搭建（nodejs,npm,mongodb）"></a>1. 工具安装和环境搭建（nodejs,npm,mongodb）</h2><ol>
<li>node 安装：<a href="www.nodejs.org">nodejs官网</a><br><code>$ sudo apt install node</code></li>
<li>安装完成之后会有 node 命令和 npm 命令<br><code>$ npm -v</code> 查看是否安装完成</li>
<li>npm 安装 cnpm 并设置淘宝源：<br><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></li>
<li>vue安装<br>全局安装 vue-cli 脚手架工具： <code>$ sudo cnpm install -g @vue/cli</code></li>
<li>mongodb 数据库的安装<br><code>$ sudo apt install mongodb</code></li>
</ol>
<h2 id="2-初始化项目（vue-cli）"><a href="#2-初始化项目（vue-cli）" class="headerlink" title="2. 初始化项目（vue-cli）"></a>2. 初始化项目（vue-cli）</h2><ol>
<li>sever 文件夹：放置服务端项目，包括给后台管理界面提供的接口和给 web 端提供的端口<ol>
<li>初始化一个 node 项目：<code>$ cnpm init -y</code></li>
<li>建立入口文件： <code>$ touch index.js</code></li>
<li>在<code>index.js</code>内自定义脚本执行 nodemo：<code>&quot;server&quot; : &quot;nodemon index.js&quot;</code></li>
<li>全局安装 nodemon：<code>$ cnpm i -g nodemon</code></li>
</ol>
</li>
<li>web 文件夹：前端界面<ol>
<li>建立 vue 初始文件：<code>$ vue create web</code></li>
<li>初始化完成后按照命令执行：<code>$ cd web</code>以及<code>$ npm run serve</code></li>
<li>进入浏览器查看 127.0.0.1:port 确认是否搭建成功</li>
</ol>
</li>
<li>admin 文件夹：管理员界面<ol>
<li>建立 vue 初始文件：<code>$ vue create admin</code></li>
<li>初始化完成后按照命令执行：<code>$ cd admin</code>以及<code>$ npm run serve</code></li>
<li>进入浏览器查看 127.0.0.1:port 确认是否搭建成功</li>
</ol>
</li>
</ol>]]></content>
      <categories>
        <category>node-vue-mongodb全栈开发</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器相关知识</title>
    <url>/2020/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="浏览器相关知识"><a href="#浏览器相关知识" class="headerlink" title="浏览器相关知识"></a>浏览器相关知识</h1><hr>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>   主流浏览器内核，主流浏览器是有一定市场份额且有自己独立研发内核的浏览器：</p>
<ol>
<li>Trident内核：代表浏览器 IE（Edge是微软随win10推出，使用的是EdgeHTML内核）</li>
<li>Gecko内核：代表浏览器 Firefox</li>
<li>Presto内核(已废弃)：Opera12.17及更早版本曾经采用的内核，现已停止开发并废弃。Opera现已改用Google Chrome的Blink内核。</li>
<li>Webkit内核：代表浏览器 Safari、Chrome。</li>
<li>Blink内核：由Google和Opera Software基于Webkit引擎研发的排版引擎，内置于Chrome浏览器之中。代表浏览器 Opera、Chrome。<br>总结为如下的表格：<table>
<thead>
<tr>
<th align="center">主流浏览器</th>
<th align="center">内核</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IE -&gt; Edge</td>
<td align="center">trident-&gt;EdgeHTML</td>
</tr>
<tr>
<td align="center">Chrome</td>
<td align="center">webkit-&gt;blink</td>
</tr>
<tr>
<td align="center">Safari</td>
<td align="center">webkit</td>
</tr>
<tr>
<td align="center">Firefox</td>
<td align="center">Gecko</td>
</tr>
<tr>
<td align="center">Opera</td>
<td align="center">Presto-&gt;blink</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="js引擎"><a href="#js引擎" class="headerlink" title="js引擎"></a>js引擎</h2><p>   主流浏览器的 js 引擎</p>
<ol>
<li>Chakra，是在IE9上使用的js引擎。</li>
<li>SpriderMonkey，TraceMonkey，JaegerMonkey这些运用在Mozilla FireFox上。</li>
<li>v8，应用于Chrome，遨游上。</li>
<li>Nitro，应用于Safari上。<br>总结如下表:<table>
<thead>
<tr>
<th align="center">主流浏览器</th>
<th align="center">js引擎</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IE -&gt; Edge</td>
<td align="center">JScript（IE3.0-IE8.0） /IE9+ Chakra</td>
</tr>
<tr>
<td align="center">Chrome</td>
<td align="center">V8</td>
</tr>
<tr>
<td align="center">Safari</td>
<td align="center">Nitro（4-）</td>
</tr>
<tr>
<td align="center">Firefox</td>
<td align="center">SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0-）</td>
</tr>
<tr>
<td align="center">Opera</td>
<td align="center">Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-）</td>
</tr>
</tbody></table>
</li>
</ol>]]></content>
      <categories>
        <category>html</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/18/hello-world/</url>
    <content><![CDATA[<p>此心安处是吾乡</p>]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
  </entry>
</search>
